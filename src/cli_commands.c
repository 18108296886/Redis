/* Automatically generated by generate-cli-commands.py, do not edit. */


/* Fallback command arg tables for use with pre-7.0 servers
 * that don't support COMMAND DOCS.
 */

/********** BITCOUNT ********************/

/* BITCOUNT index index_unit argument table */
struct commandArg BITCOUNT_index_index_unit_Subargs[] = {
{"byte",ARG_TYPE_PURE_TOKEN,"BYTE",NULL,0,0,0},
{"bit",ARG_TYPE_PURE_TOKEN,"BIT",NULL,0,0,0},
{0}
};

/* BITCOUNT index argument table */
struct commandArg BITCOUNT_index_Subargs[] = {
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"end",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"index_unit",ARG_TYPE_ONEOF,NULL,"7.0.0",1,0,0,.subargs=BITCOUNT_index_index_unit_Subargs,.numsubargs=2},
{0}
};

/* BITCOUNT argument table */
struct commandArg BITCOUNT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"index",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=BITCOUNT_index_Subargs,.numsubargs=3},
{0}
};

/********** BITFIELD ********************/

/* BITFIELD operation encoding_offset argument table */
struct commandArg BITFIELD_operation_encoding_offset_Subargs[] = {
{"encoding",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* BITFIELD operation write wrap_sat_fail argument table */
struct commandArg BITFIELD_operation_write_wrap_sat_fail_Subargs[] = {
{"wrap",ARG_TYPE_PURE_TOKEN,"WRAP",NULL,0,0,0},
{"sat",ARG_TYPE_PURE_TOKEN,"SAT",NULL,0,0,0},
{"fail",ARG_TYPE_PURE_TOKEN,"FAIL",NULL,0,0,0},
{0}
};

/* BITFIELD operation write write_operation encoding_offset_value argument table */
struct commandArg BITFIELD_operation_write_write_operation_encoding_offset_value_Subargs[] = {
{"encoding",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"value",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* BITFIELD operation write write_operation encoding_offset_increment argument table */
struct commandArg BITFIELD_operation_write_write_operation_encoding_offset_increment_Subargs[] = {
{"encoding",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"increment",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* BITFIELD operation write write_operation argument table */
struct commandArg BITFIELD_operation_write_write_operation_Subargs[] = {
{"encoding_offset_value",ARG_TYPE_BLOCK,"SET",NULL,0,0,0,.subargs=BITFIELD_operation_write_write_operation_encoding_offset_value_Subargs,.numsubargs=3},
{"encoding_offset_increment",ARG_TYPE_BLOCK,"INCRBY",NULL,0,0,0,.subargs=BITFIELD_operation_write_write_operation_encoding_offset_increment_Subargs,.numsubargs=3},
{0}
};

/* BITFIELD operation write argument table */
struct commandArg BITFIELD_operation_write_Subargs[] = {
{"wrap_sat_fail",ARG_TYPE_ONEOF,"OVERFLOW",NULL,1,0,0,.subargs=BITFIELD_operation_write_wrap_sat_fail_Subargs,.numsubargs=3},
{"write_operation",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=BITFIELD_operation_write_write_operation_Subargs,.numsubargs=2},
{0}
};

/* BITFIELD operation argument table */
struct commandArg BITFIELD_operation_Subargs[] = {
{"encoding_offset",ARG_TYPE_BLOCK,"GET",NULL,0,0,0,.subargs=BITFIELD_operation_encoding_offset_Subargs,.numsubargs=2},
{"write",ARG_TYPE_BLOCK,NULL,NULL,0,0,0,.subargs=BITFIELD_operation_write_Subargs,.numsubargs=2},
{0}
};

/* BITFIELD argument table */
struct commandArg BITFIELD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"operation",ARG_TYPE_ONEOF,NULL,NULL,0,1,0,.subargs=BITFIELD_operation_Subargs,.numsubargs=2},
{0}
};

/********** BITFIELD_RO ********************/

/* BITFIELD_RO encoding_offset argument table */
struct commandArg BITFIELD_RO_encoding_offset_Subargs[] = {
{"encoding",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* BITFIELD_RO argument table */
struct commandArg BITFIELD_RO_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"encoding_offset",ARG_TYPE_BLOCK,"GET",NULL,0,1,1,.subargs=BITFIELD_RO_encoding_offset_Subargs,.numsubargs=2},
{0}
};

/********** BITOP ********************/

/* BITOP argument table */
struct commandArg BITOP_Args[] = {
{"operation",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"destkey",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** BITPOS ********************/

/* BITPOS index end_index index_unit argument table */
struct commandArg BITPOS_index_end_index_index_unit_Subargs[] = {
{"byte",ARG_TYPE_PURE_TOKEN,"BYTE",NULL,0,0,0},
{"bit",ARG_TYPE_PURE_TOKEN,"BIT",NULL,0,0,0},
{0}
};

/* BITPOS index end_index argument table */
struct commandArg BITPOS_index_end_index_Subargs[] = {
{"end",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"index_unit",ARG_TYPE_ONEOF,NULL,"7.0.0",1,0,0,.subargs=BITPOS_index_end_index_index_unit_Subargs,.numsubargs=2},
{0}
};

/* BITPOS index argument table */
struct commandArg BITPOS_index_Subargs[] = {
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"end_index",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=BITPOS_index_end_index_Subargs,.numsubargs=2},
{0}
};

/* BITPOS argument table */
struct commandArg BITPOS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"bit",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"index",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=BITPOS_index_Subargs,.numsubargs=2},
{0}
};

/********** GETBIT ********************/

/* GETBIT argument table */
struct commandArg GETBIT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** SETBIT ********************/

/* SETBIT argument table */
struct commandArg SETBIT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"value",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** ASKING ********************/

/********** CLUSTER ADDSLOTS ********************/

/* CLUSTER ADDSLOTS argument table */
struct commandArg CLUSTER_ADDSLOTS_Args[] = {
{"slot",ARG_TYPE_INTEGER,NULL,NULL,0,1,0},
{0}
};

/********** CLUSTER ADDSLOTSRANGE ********************/

/* CLUSTER ADDSLOTSRANGE start_slot_end_slot argument table */
struct commandArg CLUSTER_ADDSLOTSRANGE_start_slot_end_slot_Subargs[] = {
{"start-slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"end-slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* CLUSTER ADDSLOTSRANGE argument table */
struct commandArg CLUSTER_ADDSLOTSRANGE_Args[] = {
{"start-slot_end-slot",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=CLUSTER_ADDSLOTSRANGE_start_slot_end_slot_Subargs,.numsubargs=2},
{0}
};

/********** CLUSTER BUMPEPOCH ********************/

/********** CLUSTER COUNT_FAILURE_REPORTS ********************/

/* CLUSTER COUNT_FAILURE_REPORTS argument table */
struct commandArg CLUSTER_COUNT_FAILURE_REPORTS_Args[] = {
{"node-id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER COUNTKEYSINSLOT ********************/

/* CLUSTER COUNTKEYSINSLOT argument table */
struct commandArg CLUSTER_COUNTKEYSINSLOT_Args[] = {
{"slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER DELSLOTS ********************/

/* CLUSTER DELSLOTS argument table */
struct commandArg CLUSTER_DELSLOTS_Args[] = {
{"slot",ARG_TYPE_INTEGER,NULL,NULL,0,1,0},
{0}
};

/********** CLUSTER DELSLOTSRANGE ********************/

/* CLUSTER DELSLOTSRANGE start_slot_end_slot argument table */
struct commandArg CLUSTER_DELSLOTSRANGE_start_slot_end_slot_Subargs[] = {
{"start-slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"end-slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* CLUSTER DELSLOTSRANGE argument table */
struct commandArg CLUSTER_DELSLOTSRANGE_Args[] = {
{"start-slot_end-slot",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=CLUSTER_DELSLOTSRANGE_start_slot_end_slot_Subargs,.numsubargs=2},
{0}
};

/********** CLUSTER FAILOVER ********************/

/* CLUSTER FAILOVER options argument table */
struct commandArg CLUSTER_FAILOVER_options_Subargs[] = {
{"force",ARG_TYPE_PURE_TOKEN,"FORCE",NULL,0,0,0},
{"takeover",ARG_TYPE_PURE_TOKEN,"TAKEOVER",NULL,0,0,0},
{0}
};

/* CLUSTER FAILOVER argument table */
struct commandArg CLUSTER_FAILOVER_Args[] = {
{"options",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=CLUSTER_FAILOVER_options_Subargs,.numsubargs=2},
{0}
};

/********** CLUSTER FLUSHSLOTS ********************/

/********** CLUSTER FORGET ********************/

/* CLUSTER FORGET argument table */
struct commandArg CLUSTER_FORGET_Args[] = {
{"node-id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER GETKEYSINSLOT ********************/

/* CLUSTER GETKEYSINSLOT argument table */
struct commandArg CLUSTER_GETKEYSINSLOT_Args[] = {
{"slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER HELP ********************/

/********** CLUSTER INFO ********************/

/********** CLUSTER KEYSLOT ********************/

/* CLUSTER KEYSLOT argument table */
struct commandArg CLUSTER_KEYSLOT_Args[] = {
{"key",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER LINKS ********************/

/********** CLUSTER MEET ********************/

/* CLUSTER MEET argument table */
struct commandArg CLUSTER_MEET_Args[] = {
{"ip",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER MYID ********************/

/********** CLUSTER NODES ********************/

/********** CLUSTER REPLICAS ********************/

/* CLUSTER REPLICAS argument table */
struct commandArg CLUSTER_REPLICAS_Args[] = {
{"node-id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER REPLICATE ********************/

/* CLUSTER REPLICATE argument table */
struct commandArg CLUSTER_REPLICATE_Args[] = {
{"node-id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER RESET ********************/

/* CLUSTER RESET hard_soft argument table */
struct commandArg CLUSTER_RESET_hard_soft_Subargs[] = {
{"hard",ARG_TYPE_PURE_TOKEN,"HARD",NULL,0,0,0},
{"soft",ARG_TYPE_PURE_TOKEN,"SOFT",NULL,0,0,0},
{0}
};

/* CLUSTER RESET argument table */
struct commandArg CLUSTER_RESET_Args[] = {
{"hard_soft",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=CLUSTER_RESET_hard_soft_Subargs,.numsubargs=2},
{0}
};

/********** CLUSTER SAVECONFIG ********************/

/********** CLUSTER SET_CONFIG_EPOCH ********************/

/* CLUSTER SET_CONFIG_EPOCH argument table */
struct commandArg CLUSTER_SET_CONFIG_EPOCH_Args[] = {
{"config-epoch",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER SETSLOT ********************/

/* CLUSTER SETSLOT subcommand argument table */
struct commandArg CLUSTER_SETSLOT_subcommand_Subargs[] = {
{"node-id",ARG_TYPE_STRING,"IMPORTING",NULL,0,0,0},
{"node-id",ARG_TYPE_STRING,"MIGRATING",NULL,0,0,0},
{"node-id",ARG_TYPE_STRING,"NODE",NULL,0,0,0},
{"stable",ARG_TYPE_PURE_TOKEN,"STABLE",NULL,0,0,0},
{0}
};

/* CLUSTER SETSLOT argument table */
struct commandArg CLUSTER_SETSLOT_Args[] = {
{"slot",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"subcommand",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=CLUSTER_SETSLOT_subcommand_Subargs,.numsubargs=4},
{0}
};

/********** CLUSTER SHARDS ********************/

/********** CLUSTER SLAVES ********************/

/* CLUSTER SLAVES argument table */
struct commandArg CLUSTER_SLAVES_Args[] = {
{"node-id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLUSTER SLOTS ********************/

/* CLUSTER command table */
struct commandDocs CLUSTER_Subcommands[] = {
{"addslots",NULL,"Assign new hash slots to receiving node","cluster","3.0.0",.args=CLUSTER_ADDSLOTS_Args,.numargs=1},
{"addslotsrange",NULL,"Assign new hash slots to receiving node","cluster","7.0.0",.args=CLUSTER_ADDSLOTSRANGE_Args,.numargs=1},
{"bumpepoch",NULL,"Advance the cluster config epoch","cluster","3.0.0"},
{"count-failure-reports",NULL,"Return the number of failure reports active for a given node","cluster","3.0.0",.args=CLUSTER_COUNT_FAILURE_REPORTS_Args,.numargs=1},
{"countkeysinslot",NULL,"Return the number of local keys in the specified hash slot","cluster","3.0.0",.args=CLUSTER_COUNTKEYSINSLOT_Args,.numargs=1},
{"delslots",NULL,"Set hash slots as unbound in receiving node","cluster","3.0.0",.args=CLUSTER_DELSLOTS_Args,.numargs=1},
{"delslotsrange",NULL,"Set hash slots as unbound in receiving node","cluster","7.0.0",.args=CLUSTER_DELSLOTSRANGE_Args,.numargs=1},
{"failover",NULL,"Forces a replica to perform a manual failover of its master.","cluster","3.0.0",.args=CLUSTER_FAILOVER_Args,.numargs=1},
{"flushslots",NULL,"Delete a node's own slots information","cluster","3.0.0"},
{"forget",NULL,"Remove a node from the nodes table","cluster","3.0.0",.args=CLUSTER_FORGET_Args,.numargs=1},
{"getkeysinslot",NULL,"Return local key names in the specified hash slot","cluster","3.0.0",.args=CLUSTER_GETKEYSINSLOT_Args,.numargs=2},
{"help",NULL,"Show helpful text about the different subcommands","cluster","5.0.0"},
{"info",NULL,"Provides info about Redis Cluster node state","cluster","3.0.0"},
{"keyslot",NULL,"Returns the hash slot of the specified key","cluster","3.0.0",.args=CLUSTER_KEYSLOT_Args,.numargs=1},
{"links",NULL,"Returns a list of all TCP links to and from peer nodes in cluster","cluster","7.0.0"},
{"meet",NULL,"Force a node cluster to handshake with another node","cluster","3.0.0",.args=CLUSTER_MEET_Args,.numargs=2},
{"myid",NULL,"Return the node id","cluster","3.0.0"},
{"nodes",NULL,"Get Cluster config for the node","cluster","3.0.0"},
{"replicas",NULL,"List replica nodes of the specified master node","cluster","5.0.0",.args=CLUSTER_REPLICAS_Args,.numargs=1},
{"replicate",NULL,"Reconfigure a node as a replica of the specified master node","cluster","3.0.0",.args=CLUSTER_REPLICATE_Args,.numargs=1},
{"reset",NULL,"Reset a Redis Cluster node","cluster","3.0.0",.args=CLUSTER_RESET_Args,.numargs=1},
{"saveconfig",NULL,"Forces the node to save cluster state on disk","cluster","3.0.0"},
{"set-config-epoch",NULL,"Set the configuration epoch in a new node","cluster","3.0.0",.args=CLUSTER_SET_CONFIG_EPOCH_Args,.numargs=1},
{"setslot",NULL,"Bind a hash slot to a specific node","cluster","3.0.0",.args=CLUSTER_SETSLOT_Args,.numargs=2},
{"shards",NULL,"Get array of cluster slots to node mappings","cluster","7.0.0"},
{"slaves",NULL,"List replica nodes of the specified master node","cluster","3.0.0",.args=CLUSTER_SLAVES_Args,.numargs=1},
{"slots",NULL,"Get array of Cluster slot to node mappings","cluster","3.0.0"},
{0}
};

/********** CLUSTER ********************/

/********** READONLY ********************/

/********** READWRITE ********************/

/********** AUTH ********************/

/* AUTH argument table */
struct commandArg AUTH_Args[] = {
{"username",ARG_TYPE_STRING,NULL,"6.0.0",1,0,0},
{"password",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLIENT CACHING ********************/

/* CLIENT CACHING mode argument table */
struct commandArg CLIENT_CACHING_mode_Subargs[] = {
{"yes",ARG_TYPE_PURE_TOKEN,"YES",NULL,0,0,0},
{"no",ARG_TYPE_PURE_TOKEN,"NO",NULL,0,0,0},
{0}
};

/* CLIENT CACHING argument table */
struct commandArg CLIENT_CACHING_Args[] = {
{"mode",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=CLIENT_CACHING_mode_Subargs,.numsubargs=2},
{0}
};

/********** CLIENT GETNAME ********************/

/********** CLIENT GETREDIR ********************/

/********** CLIENT HELP ********************/

/********** CLIENT ID ********************/

/********** CLIENT INFO ********************/

/********** CLIENT KILL ********************/

/* CLIENT KILL normal_master_slave_pubsub argument table */
struct commandArg CLIENT_KILL_normal_master_slave_pubsub_Subargs[] = {
{"normal",ARG_TYPE_PURE_TOKEN,"NORMAL",NULL,0,0,0},
{"master",ARG_TYPE_PURE_TOKEN,"MASTER","3.2.0",0,0,0},
{"slave",ARG_TYPE_PURE_TOKEN,"SLAVE",NULL,0,0,0},
{"replica",ARG_TYPE_PURE_TOKEN,"REPLICA","5.0.0",0,0,0},
{"pubsub",ARG_TYPE_PURE_TOKEN,"PUBSUB",NULL,0,0,0},
{0}
};

/* CLIENT KILL argument table */
struct commandArg CLIENT_KILL_Args[] = {
{"ip:port",ARG_TYPE_STRING,NULL,NULL,1,0,0},
{"client-id",ARG_TYPE_INTEGER,"ID","2.8.12",1,0,0},
{"normal_master_slave_pubsub",ARG_TYPE_ONEOF,"TYPE","2.8.12",1,0,0,.subargs=CLIENT_KILL_normal_master_slave_pubsub_Subargs,.numsubargs=5},
{"username",ARG_TYPE_STRING,"USER",NULL,1,0,0},
{"ip:port",ARG_TYPE_STRING,"ADDR",NULL,1,0,0},
{"ip:port",ARG_TYPE_STRING,"LADDR","6.2.0",1,0,0},
{"yes/no",ARG_TYPE_STRING,"SKIPME",NULL,1,0,0},
{0}
};

/********** CLIENT LIST ********************/

/* CLIENT LIST normal_master_replica_pubsub argument table */
struct commandArg CLIENT_LIST_normal_master_replica_pubsub_Subargs[] = {
{"normal",ARG_TYPE_PURE_TOKEN,"NORMAL",NULL,0,0,0},
{"master",ARG_TYPE_PURE_TOKEN,"MASTER",NULL,0,0,0},
{"replica",ARG_TYPE_PURE_TOKEN,"REPLICA",NULL,0,0,0},
{"pubsub",ARG_TYPE_PURE_TOKEN,"PUBSUB",NULL,0,0,0},
{0}
};

/* CLIENT LIST id argument table */
struct commandArg CLIENT_LIST_id_Subargs[] = {
{"client-id",ARG_TYPE_INTEGER,NULL,NULL,0,1,0},
{0}
};

/* CLIENT LIST argument table */
struct commandArg CLIENT_LIST_Args[] = {
{"normal_master_replica_pubsub",ARG_TYPE_ONEOF,"TYPE","5.0.0",1,0,0,.subargs=CLIENT_LIST_normal_master_replica_pubsub_Subargs,.numsubargs=4},
{"id",ARG_TYPE_BLOCK,"ID","6.2.0",1,0,0,.subargs=CLIENT_LIST_id_Subargs,.numsubargs=1},
{0}
};

/********** CLIENT NO_EVICT ********************/

/* CLIENT NO_EVICT enabled argument table */
struct commandArg CLIENT_NO_EVICT_enabled_Subargs[] = {
{"on",ARG_TYPE_PURE_TOKEN,"ON",NULL,0,0,0},
{"off",ARG_TYPE_PURE_TOKEN,"OFF",NULL,0,0,0},
{0}
};

/* CLIENT NO_EVICT argument table */
struct commandArg CLIENT_NO_EVICT_Args[] = {
{"enabled",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=CLIENT_NO_EVICT_enabled_Subargs,.numsubargs=2},
{0}
};

/********** CLIENT PAUSE ********************/

/* CLIENT PAUSE mode argument table */
struct commandArg CLIENT_PAUSE_mode_Subargs[] = {
{"write",ARG_TYPE_PURE_TOKEN,"WRITE",NULL,0,0,0},
{"all",ARG_TYPE_PURE_TOKEN,"ALL",NULL,0,0,0},
{0}
};

/* CLIENT PAUSE argument table */
struct commandArg CLIENT_PAUSE_Args[] = {
{"timeout",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"mode",ARG_TYPE_ONEOF,NULL,"6.2.0",1,0,0,.subargs=CLIENT_PAUSE_mode_Subargs,.numsubargs=2},
{0}
};

/********** CLIENT REPLY ********************/

/* CLIENT REPLY on_off_skip argument table */
struct commandArg CLIENT_REPLY_on_off_skip_Subargs[] = {
{"on",ARG_TYPE_PURE_TOKEN,"ON",NULL,0,0,0},
{"off",ARG_TYPE_PURE_TOKEN,"OFF",NULL,0,0,0},
{"skip",ARG_TYPE_PURE_TOKEN,"SKIP",NULL,0,0,0},
{0}
};

/* CLIENT REPLY argument table */
struct commandArg CLIENT_REPLY_Args[] = {
{"on_off_skip",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=CLIENT_REPLY_on_off_skip_Subargs,.numsubargs=3},
{0}
};

/********** CLIENT SETNAME ********************/

/* CLIENT SETNAME argument table */
struct commandArg CLIENT_SETNAME_Args[] = {
{"connection-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** CLIENT TRACKING ********************/

/* CLIENT TRACKING status argument table */
struct commandArg CLIENT_TRACKING_status_Subargs[] = {
{"on",ARG_TYPE_PURE_TOKEN,"ON",NULL,0,0,0},
{"off",ARG_TYPE_PURE_TOKEN,"OFF",NULL,0,0,0},
{0}
};

/* CLIENT TRACKING argument table */
struct commandArg CLIENT_TRACKING_Args[] = {
{"status",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=CLIENT_TRACKING_status_Subargs,.numsubargs=2},
{"client-id",ARG_TYPE_INTEGER,"REDIRECT",NULL,1,0,0},
{"prefix",ARG_TYPE_STRING,"PREFIX",NULL,1,1,1},
{"bcast",ARG_TYPE_PURE_TOKEN,"BCAST",NULL,1,0,0},
{"optin",ARG_TYPE_PURE_TOKEN,"OPTIN",NULL,1,0,0},
{"optout",ARG_TYPE_PURE_TOKEN,"OPTOUT",NULL,1,0,0},
{"noloop",ARG_TYPE_PURE_TOKEN,"NOLOOP",NULL,1,0,0},
{0}
};

/********** CLIENT TRACKINGINFO ********************/

/********** CLIENT UNBLOCK ********************/

/* CLIENT UNBLOCK timeout_error argument table */
struct commandArg CLIENT_UNBLOCK_timeout_error_Subargs[] = {
{"timeout",ARG_TYPE_PURE_TOKEN,"TIMEOUT",NULL,0,0,0},
{"error",ARG_TYPE_PURE_TOKEN,"ERROR",NULL,0,0,0},
{0}
};

/* CLIENT UNBLOCK argument table */
struct commandArg CLIENT_UNBLOCK_Args[] = {
{"client-id",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"timeout_error",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=CLIENT_UNBLOCK_timeout_error_Subargs,.numsubargs=2},
{0}
};

/********** CLIENT UNPAUSE ********************/

/* CLIENT command table */
struct commandDocs CLIENT_Subcommands[] = {
{"caching",NULL,"Instruct the server about tracking or not keys in the next request","connection","6.0.0",.args=CLIENT_CACHING_Args,.numargs=1},
{"getname",NULL,"Get the current connection name","connection","2.6.9"},
{"getredir",NULL,"Get tracking notifications redirection client ID if any","connection","6.0.0"},
{"help",NULL,"Show helpful text about the different subcommands","connection","5.0.0"},
{"id",NULL,"Returns the client ID for the current connection","connection","5.0.0"},
{"info",NULL,"Returns information about the current client connection.","connection","6.2.0"},
{"kill",NULL,"Kill the connection of a client","connection","2.4.0",.args=CLIENT_KILL_Args,.numargs=7},
{"list",NULL,"Get the list of client connections","connection","2.4.0",.args=CLIENT_LIST_Args,.numargs=2},
{"no-evict",NULL,"Set client eviction mode for the current connection","connection","7.0.0",.args=CLIENT_NO_EVICT_Args,.numargs=1},
{"pause",NULL,"Stop processing commands from clients for some time","connection","2.9.50",.args=CLIENT_PAUSE_Args,.numargs=2},
{"reply",NULL,"Instruct the server whether to reply to commands","connection","3.2.0",.args=CLIENT_REPLY_Args,.numargs=1},
{"setname",NULL,"Set the current connection name","connection","2.6.9",.args=CLIENT_SETNAME_Args,.numargs=1},
{"tracking",NULL,"Enable or disable server assisted client side caching support","connection","6.0.0",.args=CLIENT_TRACKING_Args,.numargs=7},
{"trackinginfo",NULL,"Return information about server assisted client side caching for the current connection","connection","6.2.0"},
{"unblock",NULL,"Unblock a client blocked in a blocking command from a different connection","connection","5.0.0",.args=CLIENT_UNBLOCK_Args,.numargs=2},
{"unpause",NULL,"Resume processing of clients that were paused","connection","6.2.0"},
{0}
};

/********** CLIENT ********************/

/********** ECHO ********************/

/* ECHO argument table */
struct commandArg ECHO_Args[] = {
{"message",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** HELLO ********************/

/* HELLO arguments username_password argument table */
struct commandArg HELLO_arguments_username_password_Subargs[] = {
{"username",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"password",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* HELLO arguments argument table */
struct commandArg HELLO_arguments_Subargs[] = {
{"protover",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"username_password",ARG_TYPE_BLOCK,"AUTH",NULL,1,0,0,.subargs=HELLO_arguments_username_password_Subargs,.numsubargs=2},
{"clientname",ARG_TYPE_STRING,"SETNAME",NULL,1,0,0},
{0}
};

/* HELLO argument table */
struct commandArg HELLO_Args[] = {
{"arguments",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=HELLO_arguments_Subargs,.numsubargs=3},
{0}
};

/********** PING ********************/

/* PING argument table */
struct commandArg PING_Args[] = {
{"message",ARG_TYPE_STRING,NULL,NULL,1,0,0},
{0}
};

/********** QUIT ********************/

/********** RESET ********************/

/********** SELECT ********************/

/* SELECT argument table */
struct commandArg SELECT_Args[] = {
{"index",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** COPY ********************/

/* COPY argument table */
struct commandArg COPY_Args[] = {
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination-db",ARG_TYPE_INTEGER,"DB",NULL,1,0,0},
{"replace",ARG_TYPE_PURE_TOKEN,"REPLACE",NULL,1,0,0},
{0}
};

/********** DEL ********************/

/* DEL argument table */
struct commandArg DEL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** DUMP ********************/

/* DUMP argument table */
struct commandArg DUMP_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** EXISTS ********************/

/* EXISTS argument table */
struct commandArg EXISTS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** EXPIRE ********************/

/* EXPIRE condition argument table */
struct commandArg EXPIRE_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{"gt",ARG_TYPE_PURE_TOKEN,"GT",NULL,0,0,0},
{"lt",ARG_TYPE_PURE_TOKEN,"LT",NULL,0,0,0},
{0}
};

/* EXPIRE argument table */
struct commandArg EXPIRE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"seconds",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"7.0.0",1,0,0,.subargs=EXPIRE_condition_Subargs,.numsubargs=4},
{0}
};

/********** EXPIREAT ********************/

/* EXPIREAT condition argument table */
struct commandArg EXPIREAT_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{"gt",ARG_TYPE_PURE_TOKEN,"GT",NULL,0,0,0},
{"lt",ARG_TYPE_PURE_TOKEN,"LT",NULL,0,0,0},
{0}
};

/* EXPIREAT argument table */
struct commandArg EXPIREAT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"unix-time-seconds",ARG_TYPE_UNIX_TIME,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"7.0.0",1,0,0,.subargs=EXPIREAT_condition_Subargs,.numsubargs=4},
{0}
};

/********** EXPIRETIME ********************/

/* EXPIRETIME argument table */
struct commandArg EXPIRETIME_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** KEYS ********************/

/* KEYS argument table */
struct commandArg KEYS_Args[] = {
{"pattern",ARG_TYPE_PATTERN,NULL,NULL,0,0,0},
{0}
};

/********** MIGRATE ********************/

/* MIGRATE key_or_empty_string argument table */
struct commandArg MIGRATE_key_or_empty_string_Subargs[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"empty_string",ARG_TYPE_PURE_TOKEN,"""",NULL,0,0,0},
{0}
};

/* MIGRATE authentication username_password argument table */
struct commandArg MIGRATE_authentication_username_password_Subargs[] = {
{"username",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"password",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* MIGRATE authentication argument table */
struct commandArg MIGRATE_authentication_Subargs[] = {
{"password",ARG_TYPE_STRING,"AUTH","4.0.7",1,0,0},
{"username_password",ARG_TYPE_BLOCK,"AUTH2","6.0.0",1,0,0,.subargs=MIGRATE_authentication_username_password_Subargs,.numsubargs=2},
{0}
};

/* MIGRATE argument table */
struct commandArg MIGRATE_Args[] = {
{"host",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key_or_empty_string",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=MIGRATE_key_or_empty_string_Subargs,.numsubargs=2},
{"destination-db",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"timeout",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"copy",ARG_TYPE_PURE_TOKEN,"COPY","3.0.0",1,0,0},
{"replace",ARG_TYPE_PURE_TOKEN,"REPLACE","3.0.0",1,0,0},
{"authentication",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=MIGRATE_authentication_Subargs,.numsubargs=2},
{"key",ARG_TYPE_KEY,"KEYS","3.0.6",1,1,0},
{0}
};

/********** MOVE ********************/

/* MOVE argument table */
struct commandArg MOVE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"db",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** OBJECT ENCODING ********************/

/* OBJECT ENCODING argument table */
struct commandArg OBJECT_ENCODING_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** OBJECT FREQ ********************/

/* OBJECT FREQ argument table */
struct commandArg OBJECT_FREQ_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** OBJECT HELP ********************/

/********** OBJECT IDLETIME ********************/

/* OBJECT IDLETIME argument table */
struct commandArg OBJECT_IDLETIME_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** OBJECT REFCOUNT ********************/

/* OBJECT REFCOUNT argument table */
struct commandArg OBJECT_REFCOUNT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/* OBJECT command table */
struct commandDocs OBJECT_Subcommands[] = {
{"encoding",NULL,"Inspect the internal encoding of a Redis object","generic","2.2.3",.args=OBJECT_ENCODING_Args,.numargs=1},
{"freq",NULL,"Get the logarithmic access frequency counter of a Redis object","generic","4.0.0",.args=OBJECT_FREQ_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","generic","6.2.0"},
{"idletime",NULL,"Get the time since a Redis object was last accessed","generic","2.2.3",.args=OBJECT_IDLETIME_Args,.numargs=1},
{"refcount",NULL,"Get the number of references to the value of the key","generic","2.2.3",.args=OBJECT_REFCOUNT_Args,.numargs=1},
{0}
};

/********** OBJECT ********************/

/********** PERSIST ********************/

/* PERSIST argument table */
struct commandArg PERSIST_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** PEXPIRE ********************/

/* PEXPIRE condition argument table */
struct commandArg PEXPIRE_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{"gt",ARG_TYPE_PURE_TOKEN,"GT",NULL,0,0,0},
{"lt",ARG_TYPE_PURE_TOKEN,"LT",NULL,0,0,0},
{0}
};

/* PEXPIRE argument table */
struct commandArg PEXPIRE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"milliseconds",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"7.0.0",1,0,0,.subargs=PEXPIRE_condition_Subargs,.numsubargs=4},
{0}
};

/********** PEXPIREAT ********************/

/* PEXPIREAT condition argument table */
struct commandArg PEXPIREAT_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{"gt",ARG_TYPE_PURE_TOKEN,"GT",NULL,0,0,0},
{"lt",ARG_TYPE_PURE_TOKEN,"LT",NULL,0,0,0},
{0}
};

/* PEXPIREAT argument table */
struct commandArg PEXPIREAT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"unix-time-milliseconds",ARG_TYPE_UNIX_TIME,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"7.0.0",1,0,0,.subargs=PEXPIREAT_condition_Subargs,.numsubargs=4},
{0}
};

/********** PEXPIRETIME ********************/

/* PEXPIRETIME argument table */
struct commandArg PEXPIRETIME_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** PTTL ********************/

/* PTTL argument table */
struct commandArg PTTL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** RANDOMKEY ********************/

/********** RENAME ********************/

/* RENAME argument table */
struct commandArg RENAME_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"newkey",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** RENAMENX ********************/

/* RENAMENX argument table */
struct commandArg RENAMENX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"newkey",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** RESTORE ********************/

/* RESTORE argument table */
struct commandArg RESTORE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"ttl",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"serialized-value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"replace",ARG_TYPE_PURE_TOKEN,"REPLACE","3.0.0",1,0,0},
{"absttl",ARG_TYPE_PURE_TOKEN,"ABSTTL","5.0.0",1,0,0},
{"seconds",ARG_TYPE_INTEGER,"IDLETIME","5.0.0",1,0,0},
{"frequency",ARG_TYPE_INTEGER,"FREQ","5.0.0",1,0,0},
{0}
};

/********** SCAN ********************/

/* SCAN argument table */
struct commandArg SCAN_Args[] = {
{"cursor",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"MATCH",NULL,1,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{"type",ARG_TYPE_STRING,"TYPE","6.0.0",1,0,0},
{0}
};

/********** SORT ********************/

/* SORT offset_count argument table */
struct commandArg SORT_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* SORT order argument table */
struct commandArg SORT_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* SORT argument table */
struct commandArg SORT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"BY",NULL,1,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=SORT_offset_count_Subargs,.numsubargs=2},
{"pattern",ARG_TYPE_PATTERN,"GET",NULL,1,1,1},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=SORT_order_Subargs,.numsubargs=2},
{"sorting",ARG_TYPE_PURE_TOKEN,"ALPHA",NULL,1,0,0},
{"destination",ARG_TYPE_KEY,"STORE",NULL,1,0,0},
{0}
};

/********** SORT_RO ********************/

/* SORT_RO offset_count argument table */
struct commandArg SORT_RO_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* SORT_RO order argument table */
struct commandArg SORT_RO_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* SORT_RO argument table */
struct commandArg SORT_RO_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"BY",NULL,1,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=SORT_RO_offset_count_Subargs,.numsubargs=2},
{"pattern",ARG_TYPE_PATTERN,"GET",NULL,1,1,1},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=SORT_RO_order_Subargs,.numsubargs=2},
{"sorting",ARG_TYPE_PURE_TOKEN,"ALPHA",NULL,1,0,0},
{0}
};

/********** TOUCH ********************/

/* TOUCH argument table */
struct commandArg TOUCH_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** TTL ********************/

/* TTL argument table */
struct commandArg TTL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** TYPE ********************/

/* TYPE argument table */
struct commandArg TYPE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** UNLINK ********************/

/* UNLINK argument table */
struct commandArg UNLINK_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** WAIT ********************/

/* WAIT argument table */
struct commandArg WAIT_Args[] = {
{"numreplicas",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"timeout",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** GEOADD ********************/

/* GEOADD condition argument table */
struct commandArg GEOADD_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{0}
};

/* GEOADD longitude_latitude_member argument table */
struct commandArg GEOADD_longitude_latitude_member_Subargs[] = {
{"longitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"latitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* GEOADD argument table */
struct commandArg GEOADD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"6.2.0",1,0,0,.subargs=GEOADD_condition_Subargs,.numsubargs=2},
{"change",ARG_TYPE_PURE_TOKEN,"CH","6.2.0",1,0,0},
{"longitude_latitude_member",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=GEOADD_longitude_latitude_member_Subargs,.numsubargs=3},
{0}
};

/********** GEODIST ********************/

/* GEODIST unit argument table */
struct commandArg GEODIST_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEODIST argument table */
struct commandArg GEODIST_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member1",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"member2",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEODIST_unit_Subargs,.numsubargs=4},
{0}
};

/********** GEOHASH ********************/

/* GEOHASH argument table */
struct commandArg GEOHASH_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** GEOPOS ********************/

/* GEOPOS argument table */
struct commandArg GEOPOS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** GEORADIUS ********************/

/* GEORADIUS unit argument table */
struct commandArg GEORADIUS_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEORADIUS count argument table */
struct commandArg GEORADIUS_count_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,0,0,0},
{"any",ARG_TYPE_PURE_TOKEN,"ANY","6.2.0",1,0,0},
{0}
};

/* GEORADIUS order argument table */
struct commandArg GEORADIUS_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* GEORADIUS argument table */
struct commandArg GEORADIUS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"longitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"latitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"radius",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEORADIUS_unit_Subargs,.numsubargs=4},
{"withcoord",ARG_TYPE_PURE_TOKEN,"WITHCOORD",NULL,1,0,0},
{"withdist",ARG_TYPE_PURE_TOKEN,"WITHDIST",NULL,1,0,0},
{"withhash",ARG_TYPE_PURE_TOKEN,"WITHHASH",NULL,1,0,0},
{"count",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=GEORADIUS_count_Subargs,.numsubargs=2},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEORADIUS_order_Subargs,.numsubargs=2},
{"key",ARG_TYPE_KEY,"STORE",NULL,1,0,0},
{"key",ARG_TYPE_KEY,"STOREDIST",NULL,1,0,0},
{0}
};

/********** GEORADIUSBYMEMBER ********************/

/* GEORADIUSBYMEMBER unit argument table */
struct commandArg GEORADIUSBYMEMBER_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEORADIUSBYMEMBER count argument table */
struct commandArg GEORADIUSBYMEMBER_count_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,0,0,0},
{"any",ARG_TYPE_PURE_TOKEN,"ANY",NULL,1,0,0},
{0}
};

/* GEORADIUSBYMEMBER order argument table */
struct commandArg GEORADIUSBYMEMBER_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* GEORADIUSBYMEMBER argument table */
struct commandArg GEORADIUSBYMEMBER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"radius",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEORADIUSBYMEMBER_unit_Subargs,.numsubargs=4},
{"withcoord",ARG_TYPE_PURE_TOKEN,"WITHCOORD",NULL,1,0,0},
{"withdist",ARG_TYPE_PURE_TOKEN,"WITHDIST",NULL,1,0,0},
{"withhash",ARG_TYPE_PURE_TOKEN,"WITHHASH",NULL,1,0,0},
{"count",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=GEORADIUSBYMEMBER_count_Subargs,.numsubargs=2},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEORADIUSBYMEMBER_order_Subargs,.numsubargs=2},
{"key",ARG_TYPE_KEY,"STORE",NULL,1,0,0},
{"key",ARG_TYPE_KEY,"STOREDIST",NULL,1,0,0},
{0}
};

/********** GEORADIUSBYMEMBER_RO ********************/

/* GEORADIUSBYMEMBER_RO unit argument table */
struct commandArg GEORADIUSBYMEMBER_RO_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEORADIUSBYMEMBER_RO count argument table */
struct commandArg GEORADIUSBYMEMBER_RO_count_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,0,0,0},
{"any",ARG_TYPE_PURE_TOKEN,"ANY",NULL,1,0,0},
{0}
};

/* GEORADIUSBYMEMBER_RO order argument table */
struct commandArg GEORADIUSBYMEMBER_RO_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* GEORADIUSBYMEMBER_RO argument table */
struct commandArg GEORADIUSBYMEMBER_RO_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"radius",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEORADIUSBYMEMBER_RO_unit_Subargs,.numsubargs=4},
{"withcoord",ARG_TYPE_PURE_TOKEN,"WITHCOORD",NULL,1,0,0},
{"withdist",ARG_TYPE_PURE_TOKEN,"WITHDIST",NULL,1,0,0},
{"withhash",ARG_TYPE_PURE_TOKEN,"WITHHASH",NULL,1,0,0},
{"count",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=GEORADIUSBYMEMBER_RO_count_Subargs,.numsubargs=2},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEORADIUSBYMEMBER_RO_order_Subargs,.numsubargs=2},
{0}
};

/********** GEORADIUS_RO ********************/

/* GEORADIUS_RO unit argument table */
struct commandArg GEORADIUS_RO_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEORADIUS_RO count argument table */
struct commandArg GEORADIUS_RO_count_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,0,0,0},
{"any",ARG_TYPE_PURE_TOKEN,"ANY","6.2.0",1,0,0},
{0}
};

/* GEORADIUS_RO order argument table */
struct commandArg GEORADIUS_RO_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* GEORADIUS_RO argument table */
struct commandArg GEORADIUS_RO_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"longitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"latitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"radius",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEORADIUS_RO_unit_Subargs,.numsubargs=4},
{"withcoord",ARG_TYPE_PURE_TOKEN,"WITHCOORD",NULL,1,0,0},
{"withdist",ARG_TYPE_PURE_TOKEN,"WITHDIST",NULL,1,0,0},
{"withhash",ARG_TYPE_PURE_TOKEN,"WITHHASH",NULL,1,0,0},
{"count",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=GEORADIUS_RO_count_Subargs,.numsubargs=2},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEORADIUS_RO_order_Subargs,.numsubargs=2},
{0}
};

/********** GEOSEARCH ********************/

/* GEOSEARCH from longitude_latitude argument table */
struct commandArg GEOSEARCH_from_longitude_latitude_Subargs[] = {
{"longitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"latitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/* GEOSEARCH from argument table */
struct commandArg GEOSEARCH_from_Subargs[] = {
{"member",ARG_TYPE_STRING,"FROMMEMBER",NULL,0,0,0},
{"longitude_latitude",ARG_TYPE_BLOCK,"FROMLONLAT",NULL,0,0,0,.subargs=GEOSEARCH_from_longitude_latitude_Subargs,.numsubargs=2},
{0}
};

/* GEOSEARCH by circle unit argument table */
struct commandArg GEOSEARCH_by_circle_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEOSEARCH by circle argument table */
struct commandArg GEOSEARCH_by_circle_Subargs[] = {
{"radius",ARG_TYPE_DOUBLE,"BYRADIUS",NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCH_by_circle_unit_Subargs,.numsubargs=4},
{0}
};

/* GEOSEARCH by box unit argument table */
struct commandArg GEOSEARCH_by_box_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEOSEARCH by box argument table */
struct commandArg GEOSEARCH_by_box_Subargs[] = {
{"width",ARG_TYPE_DOUBLE,"BYBOX",NULL,0,0,0},
{"height",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCH_by_box_unit_Subargs,.numsubargs=4},
{0}
};

/* GEOSEARCH by argument table */
struct commandArg GEOSEARCH_by_Subargs[] = {
{"circle",ARG_TYPE_BLOCK,NULL,NULL,0,0,0,.subargs=GEOSEARCH_by_circle_Subargs,.numsubargs=2},
{"box",ARG_TYPE_BLOCK,NULL,NULL,0,0,0,.subargs=GEOSEARCH_by_box_Subargs,.numsubargs=3},
{0}
};

/* GEOSEARCH order argument table */
struct commandArg GEOSEARCH_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* GEOSEARCH count argument table */
struct commandArg GEOSEARCH_count_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,0,0,0},
{"any",ARG_TYPE_PURE_TOKEN,"ANY",NULL,1,0,0},
{0}
};

/* GEOSEARCH argument table */
struct commandArg GEOSEARCH_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"from",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCH_from_Subargs,.numsubargs=2},
{"by",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCH_by_Subargs,.numsubargs=2},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEOSEARCH_order_Subargs,.numsubargs=2},
{"count",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=GEOSEARCH_count_Subargs,.numsubargs=2},
{"withcoord",ARG_TYPE_PURE_TOKEN,"WITHCOORD",NULL,1,0,0},
{"withdist",ARG_TYPE_PURE_TOKEN,"WITHDIST",NULL,1,0,0},
{"withhash",ARG_TYPE_PURE_TOKEN,"WITHHASH",NULL,1,0,0},
{0}
};

/********** GEOSEARCHSTORE ********************/

/* GEOSEARCHSTORE from longitude_latitude argument table */
struct commandArg GEOSEARCHSTORE_from_longitude_latitude_Subargs[] = {
{"longitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"latitude",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/* GEOSEARCHSTORE from argument table */
struct commandArg GEOSEARCHSTORE_from_Subargs[] = {
{"member",ARG_TYPE_STRING,"FROMMEMBER",NULL,0,0,0},
{"longitude_latitude",ARG_TYPE_BLOCK,"FROMLONLAT",NULL,0,0,0,.subargs=GEOSEARCHSTORE_from_longitude_latitude_Subargs,.numsubargs=2},
{0}
};

/* GEOSEARCHSTORE by circle unit argument table */
struct commandArg GEOSEARCHSTORE_by_circle_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEOSEARCHSTORE by circle argument table */
struct commandArg GEOSEARCHSTORE_by_circle_Subargs[] = {
{"radius",ARG_TYPE_DOUBLE,"BYRADIUS",NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCHSTORE_by_circle_unit_Subargs,.numsubargs=4},
{0}
};

/* GEOSEARCHSTORE by box unit argument table */
struct commandArg GEOSEARCHSTORE_by_box_unit_Subargs[] = {
{"m",ARG_TYPE_PURE_TOKEN,"M",NULL,0,0,0},
{"km",ARG_TYPE_PURE_TOKEN,"KM",NULL,0,0,0},
{"ft",ARG_TYPE_PURE_TOKEN,"FT",NULL,0,0,0},
{"mi",ARG_TYPE_PURE_TOKEN,"MI",NULL,0,0,0},
{0}
};

/* GEOSEARCHSTORE by box argument table */
struct commandArg GEOSEARCHSTORE_by_box_Subargs[] = {
{"width",ARG_TYPE_DOUBLE,"BYBOX",NULL,0,0,0},
{"height",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"unit",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCHSTORE_by_box_unit_Subargs,.numsubargs=4},
{0}
};

/* GEOSEARCHSTORE by argument table */
struct commandArg GEOSEARCHSTORE_by_Subargs[] = {
{"circle",ARG_TYPE_BLOCK,NULL,NULL,0,0,0,.subargs=GEOSEARCHSTORE_by_circle_Subargs,.numsubargs=2},
{"box",ARG_TYPE_BLOCK,NULL,NULL,0,0,0,.subargs=GEOSEARCHSTORE_by_box_Subargs,.numsubargs=3},
{0}
};

/* GEOSEARCHSTORE order argument table */
struct commandArg GEOSEARCHSTORE_order_Subargs[] = {
{"asc",ARG_TYPE_PURE_TOKEN,"ASC",NULL,0,0,0},
{"desc",ARG_TYPE_PURE_TOKEN,"DESC",NULL,0,0,0},
{0}
};

/* GEOSEARCHSTORE count argument table */
struct commandArg GEOSEARCHSTORE_count_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,0,0,0},
{"any",ARG_TYPE_PURE_TOKEN,"ANY",NULL,1,0,0},
{0}
};

/* GEOSEARCHSTORE argument table */
struct commandArg GEOSEARCHSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"from",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCHSTORE_from_Subargs,.numsubargs=2},
{"by",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=GEOSEARCHSTORE_by_Subargs,.numsubargs=2},
{"order",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GEOSEARCHSTORE_order_Subargs,.numsubargs=2},
{"count",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=GEOSEARCHSTORE_count_Subargs,.numsubargs=2},
{"storedist",ARG_TYPE_PURE_TOKEN,"STOREDIST",NULL,1,0,0},
{0}
};

/********** HDEL ********************/

/* HDEL argument table */
struct commandArg HDEL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** HEXISTS ********************/

/* HEXISTS argument table */
struct commandArg HEXISTS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** HGET ********************/

/* HGET argument table */
struct commandArg HGET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** HGETALL ********************/

/* HGETALL argument table */
struct commandArg HGETALL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** HINCRBY ********************/

/* HINCRBY argument table */
struct commandArg HINCRBY_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"increment",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** HINCRBYFLOAT ********************/

/* HINCRBYFLOAT argument table */
struct commandArg HINCRBYFLOAT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"increment",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** HKEYS ********************/

/* HKEYS argument table */
struct commandArg HKEYS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** HLEN ********************/

/* HLEN argument table */
struct commandArg HLEN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** HMGET ********************/

/* HMGET argument table */
struct commandArg HMGET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** HMSET ********************/

/* HMSET field_value argument table */
struct commandArg HMSET_field_value_Subargs[] = {
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* HMSET argument table */
struct commandArg HMSET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=HMSET_field_value_Subargs,.numsubargs=2},
{0}
};

/********** HRANDFIELD ********************/

/* HRANDFIELD options argument table */
struct commandArg HRANDFIELD_options_Subargs[] = {
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"withvalues",ARG_TYPE_PURE_TOKEN,"WITHVALUES",NULL,1,0,0},
{0}
};

/* HRANDFIELD argument table */
struct commandArg HRANDFIELD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"options",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=HRANDFIELD_options_Subargs,.numsubargs=2},
{0}
};

/********** HSCAN ********************/

/* HSCAN argument table */
struct commandArg HSCAN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"cursor",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"MATCH",NULL,1,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** HSET ********************/

/* HSET field_value argument table */
struct commandArg HSET_field_value_Subargs[] = {
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* HSET argument table */
struct commandArg HSET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=HSET_field_value_Subargs,.numsubargs=2},
{0}
};

/********** HSETNX ********************/

/* HSETNX argument table */
struct commandArg HSETNX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** HSTRLEN ********************/

/* HSTRLEN argument table */
struct commandArg HSTRLEN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** HVALS ********************/

/* HVALS argument table */
struct commandArg HVALS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** PFADD ********************/

/* PFADD argument table */
struct commandArg PFADD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** PFCOUNT ********************/

/* PFCOUNT argument table */
struct commandArg PFCOUNT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** PFDEBUG ********************/

/* PFDEBUG argument table */
struct commandArg PFDEBUG_Args[] = {
{"subcommand",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** PFMERGE ********************/

/* PFMERGE argument table */
struct commandArg PFMERGE_Args[] = {
{"destkey",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"sourcekey",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** PFSELFTEST ********************/

/********** BLMOVE ********************/

/* BLMOVE wherefrom argument table */
struct commandArg BLMOVE_wherefrom_Subargs[] = {
{"left",ARG_TYPE_PURE_TOKEN,"LEFT",NULL,0,0,0},
{"right",ARG_TYPE_PURE_TOKEN,"RIGHT",NULL,0,0,0},
{0}
};

/* BLMOVE whereto argument table */
struct commandArg BLMOVE_whereto_Subargs[] = {
{"left",ARG_TYPE_PURE_TOKEN,"LEFT",NULL,0,0,0},
{"right",ARG_TYPE_PURE_TOKEN,"RIGHT",NULL,0,0,0},
{0}
};

/* BLMOVE argument table */
struct commandArg BLMOVE_Args[] = {
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"wherefrom",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=BLMOVE_wherefrom_Subargs,.numsubargs=2},
{"whereto",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=BLMOVE_whereto_Subargs,.numsubargs=2},
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** BLMPOP ********************/

/* BLMPOP where argument table */
struct commandArg BLMPOP_where_Subargs[] = {
{"left",ARG_TYPE_PURE_TOKEN,"LEFT",NULL,0,0,0},
{"right",ARG_TYPE_PURE_TOKEN,"RIGHT",NULL,0,0,0},
{0}
};

/* BLMPOP argument table */
struct commandArg BLMPOP_Args[] = {
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"where",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=BLMPOP_where_Subargs,.numsubargs=2},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** BLPOP ********************/

/* BLPOP argument table */
struct commandArg BLPOP_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** BRPOP ********************/

/* BRPOP argument table */
struct commandArg BRPOP_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** BRPOPLPUSH ********************/

/* BRPOPLPUSH argument table */
struct commandArg BRPOPLPUSH_Args[] = {
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** LINDEX ********************/

/* LINDEX argument table */
struct commandArg LINDEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"index",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** LINSERT ********************/

/* LINSERT where argument table */
struct commandArg LINSERT_where_Subargs[] = {
{"before",ARG_TYPE_PURE_TOKEN,"BEFORE",NULL,0,0,0},
{"after",ARG_TYPE_PURE_TOKEN,"AFTER",NULL,0,0,0},
{0}
};

/* LINSERT argument table */
struct commandArg LINSERT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"where",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=LINSERT_where_Subargs,.numsubargs=2},
{"pivot",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** LLEN ********************/

/* LLEN argument table */
struct commandArg LLEN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** LMOVE ********************/

/* LMOVE wherefrom argument table */
struct commandArg LMOVE_wherefrom_Subargs[] = {
{"left",ARG_TYPE_PURE_TOKEN,"LEFT",NULL,0,0,0},
{"right",ARG_TYPE_PURE_TOKEN,"RIGHT",NULL,0,0,0},
{0}
};

/* LMOVE whereto argument table */
struct commandArg LMOVE_whereto_Subargs[] = {
{"left",ARG_TYPE_PURE_TOKEN,"LEFT",NULL,0,0,0},
{"right",ARG_TYPE_PURE_TOKEN,"RIGHT",NULL,0,0,0},
{0}
};

/* LMOVE argument table */
struct commandArg LMOVE_Args[] = {
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"wherefrom",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=LMOVE_wherefrom_Subargs,.numsubargs=2},
{"whereto",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=LMOVE_whereto_Subargs,.numsubargs=2},
{0}
};

/********** LMPOP ********************/

/* LMPOP where argument table */
struct commandArg LMPOP_where_Subargs[] = {
{"left",ARG_TYPE_PURE_TOKEN,"LEFT",NULL,0,0,0},
{"right",ARG_TYPE_PURE_TOKEN,"RIGHT",NULL,0,0,0},
{0}
};

/* LMPOP argument table */
struct commandArg LMPOP_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"where",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=LMPOP_where_Subargs,.numsubargs=2},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** LPOP ********************/

/* LPOP argument table */
struct commandArg LPOP_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,"6.2.0",1,0,0},
{0}
};

/********** LPOS ********************/

/* LPOS argument table */
struct commandArg LPOS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"rank",ARG_TYPE_INTEGER,"RANK",NULL,1,0,0},
{"num-matches",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{"len",ARG_TYPE_INTEGER,"MAXLEN",NULL,1,0,0},
{0}
};

/********** LPUSH ********************/

/* LPUSH argument table */
struct commandArg LPUSH_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** LPUSHX ********************/

/* LPUSHX argument table */
struct commandArg LPUSHX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** LRANGE ********************/

/* LRANGE argument table */
struct commandArg LRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"stop",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** LREM ********************/

/* LREM argument table */
struct commandArg LREM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** LSET ********************/

/* LSET argument table */
struct commandArg LSET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"index",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** LTRIM ********************/

/* LTRIM argument table */
struct commandArg LTRIM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"stop",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** RPOP ********************/

/* RPOP argument table */
struct commandArg RPOP_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,"6.2.0",1,0,0},
{0}
};

/********** RPOPLPUSH ********************/

/* RPOPLPUSH argument table */
struct commandArg RPOPLPUSH_Args[] = {
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** RPUSH ********************/

/* RPUSH argument table */
struct commandArg RPUSH_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** RPUSHX ********************/

/* RPUSHX argument table */
struct commandArg RPUSHX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"element",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** PSUBSCRIBE ********************/

/* PSUBSCRIBE pattern argument table */
struct commandArg PSUBSCRIBE_pattern_Subargs[] = {
{"pattern",ARG_TYPE_PATTERN,NULL,NULL,0,0,0},
{0}
};

/* PSUBSCRIBE argument table */
struct commandArg PSUBSCRIBE_Args[] = {
{"pattern",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=PSUBSCRIBE_pattern_Subargs,.numsubargs=1},
{0}
};

/********** PUBLISH ********************/

/* PUBLISH argument table */
struct commandArg PUBLISH_Args[] = {
{"channel",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"message",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** PUBSUB CHANNELS ********************/

/* PUBSUB CHANNELS argument table */
struct commandArg PUBSUB_CHANNELS_Args[] = {
{"pattern",ARG_TYPE_PATTERN,NULL,NULL,1,0,0},
{0}
};

/********** PUBSUB HELP ********************/

/********** PUBSUB NUMPAT ********************/

/********** PUBSUB NUMSUB ********************/

/* PUBSUB NUMSUB argument table */
struct commandArg PUBSUB_NUMSUB_Args[] = {
{"channel",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** PUBSUB SHARDCHANNELS ********************/

/* PUBSUB SHARDCHANNELS argument table */
struct commandArg PUBSUB_SHARDCHANNELS_Args[] = {
{"pattern",ARG_TYPE_PATTERN,NULL,NULL,1,0,0},
{0}
};

/********** PUBSUB SHARDNUMSUB ********************/

/* PUBSUB SHARDNUMSUB argument table */
struct commandArg PUBSUB_SHARDNUMSUB_Args[] = {
{"shardchannel",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/* PUBSUB command table */
struct commandDocs PUBSUB_Subcommands[] = {
{"channels",NULL,"List active channels","pubsub","2.8.0",.args=PUBSUB_CHANNELS_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","pubsub","6.2.0"},
{"numpat",NULL,"Get the count of unique patterns pattern subscriptions","pubsub","2.8.0"},
{"numsub",NULL,"Get the count of subscribers for channels","pubsub","2.8.0",.args=PUBSUB_NUMSUB_Args,.numargs=1},
{"shardchannels",NULL,"List active shard channels","pubsub","7.0.0",.args=PUBSUB_SHARDCHANNELS_Args,.numargs=1},
{"shardnumsub",NULL,"Get the count of subscribers for shard channels","pubsub","7.0.0",.args=PUBSUB_SHARDNUMSUB_Args,.numargs=1},
{0}
};

/********** PUBSUB ********************/

/********** PUNSUBSCRIBE ********************/

/* PUNSUBSCRIBE argument table */
struct commandArg PUNSUBSCRIBE_Args[] = {
{"pattern",ARG_TYPE_PATTERN,NULL,NULL,1,1,0},
{0}
};

/********** SPUBLISH ********************/

/* SPUBLISH argument table */
struct commandArg SPUBLISH_Args[] = {
{"shardchannel",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"message",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SSUBSCRIBE ********************/

/* SSUBSCRIBE argument table */
struct commandArg SSUBSCRIBE_Args[] = {
{"shardchannel",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SUBSCRIBE ********************/

/* SUBSCRIBE argument table */
struct commandArg SUBSCRIBE_Args[] = {
{"channel",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SUNSUBSCRIBE ********************/

/* SUNSUBSCRIBE argument table */
struct commandArg SUNSUBSCRIBE_Args[] = {
{"shardchannel",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** UNSUBSCRIBE ********************/

/* UNSUBSCRIBE argument table */
struct commandArg UNSUBSCRIBE_Args[] = {
{"channel",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** EVAL ********************/

/* EVAL argument table */
struct commandArg EVAL_Args[] = {
{"script",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,1,1,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** EVALSHA ********************/

/* EVALSHA argument table */
struct commandArg EVALSHA_Args[] = {
{"sha1",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,1,1,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** EVALSHA_RO ********************/

/* EVALSHA_RO argument table */
struct commandArg EVALSHA_RO_Args[] = {
{"sha1",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** EVAL_RO ********************/

/* EVAL_RO argument table */
struct commandArg EVAL_RO_Args[] = {
{"script",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** FCALL ********************/

/* FCALL argument table */
struct commandArg FCALL_Args[] = {
{"function",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** FCALL_RO ********************/

/* FCALL_RO argument table */
struct commandArg FCALL_RO_Args[] = {
{"function",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** FUNCTION DELETE ********************/

/* FUNCTION DELETE argument table */
struct commandArg FUNCTION_DELETE_Args[] = {
{"library-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** FUNCTION DUMP ********************/

/********** FUNCTION FLUSH ********************/

/* FUNCTION FLUSH async argument table */
struct commandArg FUNCTION_FLUSH_async_Subargs[] = {
{"async",ARG_TYPE_PURE_TOKEN,"ASYNC",NULL,0,0,0},
{"sync",ARG_TYPE_PURE_TOKEN,"SYNC",NULL,0,0,0},
{0}
};

/* FUNCTION FLUSH argument table */
struct commandArg FUNCTION_FLUSH_Args[] = {
{"async",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=FUNCTION_FLUSH_async_Subargs,.numsubargs=2},
{0}
};

/********** FUNCTION HELP ********************/

/********** FUNCTION KILL ********************/

/********** FUNCTION LIST ********************/

/* FUNCTION LIST argument table */
struct commandArg FUNCTION_LIST_Args[] = {
{"library-name-pattern",ARG_TYPE_STRING,"LIBRARYNAME",NULL,1,0,0},
{"withcode",ARG_TYPE_PURE_TOKEN,"WITHCODE",NULL,1,0,0},
{0}
};

/********** FUNCTION LOAD ********************/

/* FUNCTION LOAD argument table */
struct commandArg FUNCTION_LOAD_Args[] = {
{"replace",ARG_TYPE_PURE_TOKEN,"REPLACE",NULL,1,0,0},
{"function-code",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** FUNCTION RESTORE ********************/

/* FUNCTION RESTORE policy argument table */
struct commandArg FUNCTION_RESTORE_policy_Subargs[] = {
{"flush",ARG_TYPE_PURE_TOKEN,"FLUSH",NULL,0,0,0},
{"append",ARG_TYPE_PURE_TOKEN,"APPEND",NULL,0,0,0},
{"replace",ARG_TYPE_PURE_TOKEN,"REPLACE",NULL,0,0,0},
{0}
};

/* FUNCTION RESTORE argument table */
struct commandArg FUNCTION_RESTORE_Args[] = {
{"serialized-value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"policy",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=FUNCTION_RESTORE_policy_Subargs,.numsubargs=3},
{0}
};

/********** FUNCTION STATS ********************/

/* FUNCTION command table */
struct commandDocs FUNCTION_Subcommands[] = {
{"delete",NULL,"Delete a function by name","scripting","7.0.0",.args=FUNCTION_DELETE_Args,.numargs=1},
{"dump",NULL,"Dump all functions into a serialized binary payload","scripting","7.0.0"},
{"flush",NULL,"Deleting all functions","scripting","7.0.0",.args=FUNCTION_FLUSH_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","scripting","7.0.0"},
{"kill",NULL,"Kill the function currently in execution.","scripting","7.0.0"},
{"list",NULL,"List information about all the functions","scripting","7.0.0",.args=FUNCTION_LIST_Args,.numargs=2},
{"load",NULL,"Create a function with the given arguments (name, code, description)","scripting","7.0.0",.args=FUNCTION_LOAD_Args,.numargs=2},
{"restore",NULL,"Restore all the functions on the given payload","scripting","7.0.0",.args=FUNCTION_RESTORE_Args,.numargs=2},
{"stats",NULL,"Return information about the function currently running (name, description, duration)","scripting","7.0.0"},
{0}
};

/********** FUNCTION ********************/

/********** SCRIPT DEBUG ********************/

/* SCRIPT DEBUG mode argument table */
struct commandArg SCRIPT_DEBUG_mode_Subargs[] = {
{"yes",ARG_TYPE_PURE_TOKEN,"YES",NULL,0,0,0},
{"sync",ARG_TYPE_PURE_TOKEN,"SYNC",NULL,0,0,0},
{"no",ARG_TYPE_PURE_TOKEN,"NO",NULL,0,0,0},
{0}
};

/* SCRIPT DEBUG argument table */
struct commandArg SCRIPT_DEBUG_Args[] = {
{"mode",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=SCRIPT_DEBUG_mode_Subargs,.numsubargs=3},
{0}
};

/********** SCRIPT EXISTS ********************/

/* SCRIPT EXISTS argument table */
struct commandArg SCRIPT_EXISTS_Args[] = {
{"sha1",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SCRIPT FLUSH ********************/

/* SCRIPT FLUSH async argument table */
struct commandArg SCRIPT_FLUSH_async_Subargs[] = {
{"async",ARG_TYPE_PURE_TOKEN,"ASYNC",NULL,0,0,0},
{"sync",ARG_TYPE_PURE_TOKEN,"SYNC",NULL,0,0,0},
{0}
};

/* SCRIPT FLUSH argument table */
struct commandArg SCRIPT_FLUSH_Args[] = {
{"async",ARG_TYPE_ONEOF,NULL,"6.2.0",1,0,0,.subargs=SCRIPT_FLUSH_async_Subargs,.numsubargs=2},
{0}
};

/********** SCRIPT HELP ********************/

/********** SCRIPT KILL ********************/

/********** SCRIPT LOAD ********************/

/* SCRIPT LOAD argument table */
struct commandArg SCRIPT_LOAD_Args[] = {
{"script",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* SCRIPT command table */
struct commandDocs SCRIPT_Subcommands[] = {
{"debug",NULL,"Set the debug mode for executed scripts.","scripting","3.2.0",.args=SCRIPT_DEBUG_Args,.numargs=1},
{"exists",NULL,"Check existence of scripts in the script cache.","scripting","2.6.0",.args=SCRIPT_EXISTS_Args,.numargs=1},
{"flush",NULL,"Remove all the scripts from the script cache.","scripting","2.6.0",.args=SCRIPT_FLUSH_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","scripting","5.0.0"},
{"kill",NULL,"Kill the script currently in execution.","scripting","2.6.0"},
{"load",NULL,"Load the specified Lua script into the script cache.","scripting","2.6.0",.args=SCRIPT_LOAD_Args,.numargs=1},
{0}
};

/********** SCRIPT ********************/

/********** SENTINEL CKQUORUM ********************/

/* SENTINEL CKQUORUM argument table */
struct commandArg SENTINEL_CKQUORUM_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL CONFIG ********************/

/* SENTINEL CONFIG set_or_get set_param_value argument table */
struct commandArg SENTINEL_CONFIG_set_or_get_set_param_value_Subargs[] = {
{"parameter",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* SENTINEL CONFIG set_or_get argument table */
struct commandArg SENTINEL_CONFIG_set_or_get_Subargs[] = {
{"set_param_value",ARG_TYPE_BLOCK,"SET",NULL,0,1,0,.subargs=SENTINEL_CONFIG_set_or_get_set_param_value_Subargs,.numsubargs=2},
{"parameter",ARG_TYPE_STRING,"GET",NULL,0,1,0},
{0}
};

/* SENTINEL CONFIG argument table */
struct commandArg SENTINEL_CONFIG_Args[] = {
{"set_or_get",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=SENTINEL_CONFIG_set_or_get_Subargs,.numsubargs=2},
{0}
};

/********** SENTINEL DEBUG ********************/

/* SENTINEL DEBUG parameter_value argument table */
struct commandArg SENTINEL_DEBUG_parameter_value_Subargs[] = {
{"parameter",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* SENTINEL DEBUG argument table */
struct commandArg SENTINEL_DEBUG_Args[] = {
{"parameter_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=SENTINEL_DEBUG_parameter_value_Subargs,.numsubargs=2},
{0}
};

/********** SENTINEL FAILOVER ********************/

/* SENTINEL FAILOVER argument table */
struct commandArg SENTINEL_FAILOVER_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL FLUSHCONFIG ********************/

/********** SENTINEL GET_MASTER_ADDR_BY_NAME ********************/

/* SENTINEL GET_MASTER_ADDR_BY_NAME argument table */
struct commandArg SENTINEL_GET_MASTER_ADDR_BY_NAME_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL HELP ********************/

/********** SENTINEL INFO_CACHE ********************/

/* SENTINEL INFO_CACHE argument table */
struct commandArg SENTINEL_INFO_CACHE_Args[] = {
{"nodename",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SENTINEL IS_MASTER_DOWN_BY_ADDR ********************/

/* SENTINEL IS_MASTER_DOWN_BY_ADDR argument table */
struct commandArg SENTINEL_IS_MASTER_DOWN_BY_ADDR_Args[] = {
{"ip",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"current-epoch",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"runid",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL MASTER ********************/

/* SENTINEL MASTER argument table */
struct commandArg SENTINEL_MASTER_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL MASTERS ********************/

/********** SENTINEL MONITOR ********************/

/* SENTINEL MONITOR argument table */
struct commandArg SENTINEL_MONITOR_Args[] = {
{"name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"ip",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"quorum",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL MYID ********************/

/********** SENTINEL PENDING_SCRIPTS ********************/

/********** SENTINEL REMOVE ********************/

/* SENTINEL REMOVE argument table */
struct commandArg SENTINEL_REMOVE_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL REPLICAS ********************/

/* SENTINEL REPLICAS argument table */
struct commandArg SENTINEL_REPLICAS_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL RESET ********************/

/* SENTINEL RESET argument table */
struct commandArg SENTINEL_RESET_Args[] = {
{"pattern",ARG_TYPE_PATTERN,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL SENTINELS ********************/

/* SENTINEL SENTINELS argument table */
struct commandArg SENTINEL_SENTINELS_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SENTINEL SET ********************/

/* SENTINEL SET option_value argument table */
struct commandArg SENTINEL_SET_option_value_Subargs[] = {
{"option",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* SENTINEL SET argument table */
struct commandArg SENTINEL_SET_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"option_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=SENTINEL_SET_option_value_Subargs,.numsubargs=2},
{0}
};

/********** SENTINEL SIMULATE_FAILURE ********************/

/* SENTINEL SIMULATE_FAILURE mode argument table */
struct commandArg SENTINEL_SIMULATE_FAILURE_mode_Subargs[] = {
{"crash-after-election",ARG_TYPE_PURE_TOKEN,NULL,NULL,0,0,0},
{"crash-after-promotion",ARG_TYPE_PURE_TOKEN,NULL,NULL,0,0,0},
{"help",ARG_TYPE_PURE_TOKEN,NULL,NULL,0,0,0},
{0}
};

/* SENTINEL SIMULATE_FAILURE argument table */
struct commandArg SENTINEL_SIMULATE_FAILURE_Args[] = {
{"mode",ARG_TYPE_ONEOF,NULL,NULL,1,1,0,.subargs=SENTINEL_SIMULATE_FAILURE_mode_Subargs,.numsubargs=3},
{0}
};

/********** SENTINEL SLAVES ********************/

/* SENTINEL SLAVES argument table */
struct commandArg SENTINEL_SLAVES_Args[] = {
{"master-name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* SENTINEL command table */
struct commandDocs SENTINEL_Subcommands[] = {
{"ckquorum",NULL,"Check for a Sentinel quorum","sentinel","2.8.4",.args=SENTINEL_CKQUORUM_Args,.numargs=1},
{"config",NULL,"Configure Sentinel","sentinel","6.2.0",.args=SENTINEL_CONFIG_Args,.numargs=1},
{"debug",NULL,"List or update the current configurable parameters","sentinel","7.0.0",.args=SENTINEL_DEBUG_Args,.numargs=1},
{"failover",NULL,"Force a failover","sentinel","2.8.4",.args=SENTINEL_FAILOVER_Args,.numargs=1},
{"flushconfig",NULL,"Rewrite configuration file","sentinel","2.8.4"},
{"get-master-addr-by-name",NULL,"Get port and address of a master","sentinel","2.8.4",.args=SENTINEL_GET_MASTER_ADDR_BY_NAME_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","sentinel","6.2.0"},
{"info-cache",NULL,"Get cached INFO from the instances in the deployment","sentinel","3.2.0",.args=SENTINEL_INFO_CACHE_Args,.numargs=1},
{"is-master-down-by-addr",NULL,"Check if a master is down","sentinel","2.8.4",.args=SENTINEL_IS_MASTER_DOWN_BY_ADDR_Args,.numargs=4},
{"master",NULL,"Shows the state of a master","sentinel","2.8.4",.args=SENTINEL_MASTER_Args,.numargs=1},
{"masters",NULL,"List the monitored masters","sentinel","2.8.4"},
{"monitor",NULL,"Start monitoring","sentinel","2.8.4",.args=SENTINEL_MONITOR_Args,.numargs=4},
{"myid",NULL,"Get the Sentinel instance ID","sentinel","6.2.0"},
{"pending-scripts",NULL,"Get information about pending scripts","sentinel","2.8.4"},
{"remove",NULL,"Stop monitoring","sentinel","2.8.4",.args=SENTINEL_REMOVE_Args,.numargs=1},
{"replicas",NULL,"List the monitored replicas","sentinel","5.0.0",.args=SENTINEL_REPLICAS_Args,.numargs=1},
{"reset",NULL,"Reset masters by name pattern","sentinel","2.8.4",.args=SENTINEL_RESET_Args,.numargs=1},
{"sentinels",NULL,"List the Sentinel instances","sentinel","2.8.4",.args=SENTINEL_SENTINELS_Args,.numargs=1},
{"set",NULL,"Change the configuration of a monitored master","sentinel","2.8.4",.args=SENTINEL_SET_Args,.numargs=2},
{"simulate-failure",NULL,"Simulate failover scenarios","sentinel","3.2.0",.args=SENTINEL_SIMULATE_FAILURE_Args,.numargs=1},
{"slaves",NULL,"List the monitored slaves","sentinel","2.8.0",.args=SENTINEL_SLAVES_Args,.numargs=1},
{0}
};

/********** SENTINEL ********************/

/********** ACL CAT ********************/

/* ACL CAT argument table */
struct commandArg ACL_CAT_Args[] = {
{"categoryname",ARG_TYPE_STRING,NULL,NULL,1,0,0},
{0}
};

/********** ACL DELUSER ********************/

/* ACL DELUSER argument table */
struct commandArg ACL_DELUSER_Args[] = {
{"username",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** ACL DRYRUN ********************/

/* ACL DRYRUN argument table */
struct commandArg ACL_DRYRUN_Args[] = {
{"username",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"command",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** ACL GENPASS ********************/

/* ACL GENPASS argument table */
struct commandArg ACL_GENPASS_Args[] = {
{"bits",ARG_TYPE_INTEGER,NULL,NULL,1,0,0},
{0}
};

/********** ACL GETUSER ********************/

/* ACL GETUSER argument table */
struct commandArg ACL_GETUSER_Args[] = {
{"username",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ACL HELP ********************/

/********** ACL LIST ********************/

/********** ACL LOAD ********************/

/********** ACL LOG ********************/

/* ACL LOG operation argument table */
struct commandArg ACL_LOG_operation_Subargs[] = {
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"reset",ARG_TYPE_PURE_TOKEN,"RESET",NULL,0,0,0},
{0}
};

/* ACL LOG argument table */
struct commandArg ACL_LOG_Args[] = {
{"operation",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=ACL_LOG_operation_Subargs,.numsubargs=2},
{0}
};

/********** ACL SAVE ********************/

/********** ACL SETUSER ********************/

/* ACL SETUSER argument table */
struct commandArg ACL_SETUSER_Args[] = {
{"username",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"rule",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** ACL USERS ********************/

/********** ACL WHOAMI ********************/

/* ACL command table */
struct commandDocs ACL_Subcommands[] = {
{"cat",NULL,"List the ACL categories or the commands inside a category","server","6.0.0",.args=ACL_CAT_Args,.numargs=1},
{"deluser",NULL,"Remove the specified ACL users and the associated rules","server","6.0.0",.args=ACL_DELUSER_Args,.numargs=1},
{"dryrun",NULL,"Returns whether the user can execute the given command without executing the command.","server","7.0.0",.args=ACL_DRYRUN_Args,.numargs=3},
{"genpass",NULL,"Generate a pseudorandom secure password to use for ACL users","server","6.0.0",.args=ACL_GENPASS_Args,.numargs=1},
{"getuser",NULL,"Get the rules for a specific ACL user","server","6.0.0",.args=ACL_GETUSER_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","server","6.0.0"},
{"list",NULL,"List the current ACL rules in ACL config file format","server","6.0.0"},
{"load",NULL,"Reload the ACLs from the configured ACL file","server","6.0.0"},
{"log",NULL,"List latest events denied because of ACLs in place","server","6.0.0",.args=ACL_LOG_Args,.numargs=1},
{"save",NULL,"Save the current ACL rules in the configured ACL file","server","6.0.0"},
{"setuser",NULL,"Modify or create the rules for a specific ACL user","server","6.0.0",.args=ACL_SETUSER_Args,.numargs=2},
{"users",NULL,"List the username of all the configured ACL rules","server","6.0.0"},
{"whoami",NULL,"Return the name of the user associated to the current connection","server","6.0.0"},
{0}
};

/********** ACL ********************/

/********** BGREWRITEAOF ********************/

/********** BGSAVE ********************/

/* BGSAVE argument table */
struct commandArg BGSAVE_Args[] = {
{"schedule",ARG_TYPE_PURE_TOKEN,"SCHEDULE","3.2.2",1,0,0},
{0}
};

/********** COMMAND COUNT ********************/

/********** COMMAND DOCS ********************/

/* COMMAND DOCS argument table */
struct commandArg COMMAND_DOCS_Args[] = {
{"command-name",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** COMMAND GETKEYS ********************/

/********** COMMAND GETKEYSANDFLAGS ********************/

/********** COMMAND HELP ********************/

/********** COMMAND INFO ********************/

/* COMMAND INFO argument table */
struct commandArg COMMAND_INFO_Args[] = {
{"command-name",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** COMMAND LIST ********************/

/* COMMAND LIST filterby argument table */
struct commandArg COMMAND_LIST_filterby_Subargs[] = {
{"module-name",ARG_TYPE_STRING,"MODULE",NULL,0,0,0},
{"category",ARG_TYPE_STRING,"ACLCAT",NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"PATTERN",NULL,0,0,0},
{0}
};

/* COMMAND LIST argument table */
struct commandArg COMMAND_LIST_Args[] = {
{"filterby",ARG_TYPE_ONEOF,"FILTERBY",NULL,1,0,0,.subargs=COMMAND_LIST_filterby_Subargs,.numsubargs=3},
{0}
};

/* COMMAND command table */
struct commandDocs COMMAND_Subcommands[] = {
{"count",NULL,"Get total number of Redis commands","server","2.8.13"},
{"docs",NULL,"Get array of specific Redis command documentation","server","7.0.0",.args=COMMAND_DOCS_Args,.numargs=1},
{"getkeys",NULL,"Extract keys given a full Redis command","server","2.8.13"},
{"getkeysandflags",NULL,"Extract keys and access flags given a full Redis command","server","7.0.0"},
{"help",NULL,"Show helpful text about the different subcommands","server","5.0.0"},
{"info",NULL,"Get array of specific Redis command details, or all when no argument is given.","server","2.8.13",.args=COMMAND_INFO_Args,.numargs=1},
{"list",NULL,"Get an array of Redis command names","server","7.0.0",.args=COMMAND_LIST_Args,.numargs=1},
{0}
};

/********** COMMAND ********************/

/********** CONFIG GET ********************/

/* CONFIG GET parameter argument table */
struct commandArg CONFIG_GET_parameter_Subargs[] = {
{"parameter",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* CONFIG GET argument table */
struct commandArg CONFIG_GET_Args[] = {
{"parameter",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=CONFIG_GET_parameter_Subargs,.numsubargs=1},
{0}
};

/********** CONFIG HELP ********************/

/********** CONFIG RESETSTAT ********************/

/********** CONFIG REWRITE ********************/

/********** CONFIG SET ********************/

/* CONFIG SET parameter_value argument table */
struct commandArg CONFIG_SET_parameter_value_Subargs[] = {
{"parameter",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* CONFIG SET argument table */
struct commandArg CONFIG_SET_Args[] = {
{"parameter_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=CONFIG_SET_parameter_value_Subargs,.numsubargs=2},
{0}
};

/* CONFIG command table */
struct commandDocs CONFIG_Subcommands[] = {
{"get",NULL,"Get the values of configuration parameters","server","2.0.0",.args=CONFIG_GET_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","server","5.0.0"},
{"resetstat",NULL,"Reset the stats returned by INFO","server","2.0.0"},
{"rewrite",NULL,"Rewrite the configuration file with the in memory configuration","server","2.8.0"},
{"set",NULL,"Set configuration parameters to the given values","server","2.0.0",.args=CONFIG_SET_Args,.numargs=1},
{0}
};

/********** CONFIG ********************/

/********** DBSIZE ********************/

/********** DEBUG ********************/

/********** FAILOVER ********************/

/* FAILOVER target argument table */
struct commandArg FAILOVER_target_Subargs[] = {
{"host",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"force",ARG_TYPE_PURE_TOKEN,"FORCE",NULL,1,0,0},
{0}
};

/* FAILOVER argument table */
struct commandArg FAILOVER_Args[] = {
{"target",ARG_TYPE_BLOCK,"TO",NULL,1,0,0,.subargs=FAILOVER_target_Subargs,.numsubargs=3},
{"abort",ARG_TYPE_PURE_TOKEN,"ABORT",NULL,1,0,0},
{"milliseconds",ARG_TYPE_INTEGER,"TIMEOUT",NULL,1,0,0},
{0}
};

/********** FLUSHALL ********************/

/* FLUSHALL async argument table */
struct commandArg FLUSHALL_async_Subargs[] = {
{"async",ARG_TYPE_PURE_TOKEN,"ASYNC","4.0.0",0,0,0},
{"sync",ARG_TYPE_PURE_TOKEN,"SYNC","6.2.0",0,0,0},
{0}
};

/* FLUSHALL argument table */
struct commandArg FLUSHALL_Args[] = {
{"async",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=FLUSHALL_async_Subargs,.numsubargs=2},
{0}
};

/********** FLUSHDB ********************/

/* FLUSHDB async argument table */
struct commandArg FLUSHDB_async_Subargs[] = {
{"async",ARG_TYPE_PURE_TOKEN,"ASYNC","4.0.0",0,0,0},
{"sync",ARG_TYPE_PURE_TOKEN,"SYNC","6.2.0",0,0,0},
{0}
};

/* FLUSHDB argument table */
struct commandArg FLUSHDB_Args[] = {
{"async",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=FLUSHDB_async_Subargs,.numsubargs=2},
{0}
};

/********** INFO ********************/

/* INFO argument table */
struct commandArg INFO_Args[] = {
{"section",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** LASTSAVE ********************/

/********** LATENCY DOCTOR ********************/

/********** LATENCY GRAPH ********************/

/* LATENCY GRAPH argument table */
struct commandArg LATENCY_GRAPH_Args[] = {
{"event",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** LATENCY HELP ********************/

/********** LATENCY HISTOGRAM ********************/

/* LATENCY HISTOGRAM argument table */
struct commandArg LATENCY_HISTOGRAM_Args[] = {
{"command",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** LATENCY HISTORY ********************/

/* LATENCY HISTORY argument table */
struct commandArg LATENCY_HISTORY_Args[] = {
{"event",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** LATENCY LATEST ********************/

/********** LATENCY RESET ********************/

/* LATENCY RESET argument table */
struct commandArg LATENCY_RESET_Args[] = {
{"event",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/* LATENCY command table */
struct commandDocs LATENCY_Subcommands[] = {
{"doctor",NULL,"Return a human readable latency analysis report.","server","2.8.13"},
{"graph",NULL,"Return a latency graph for the event.","server","2.8.13",.args=LATENCY_GRAPH_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands.","server","2.8.13"},
{"histogram",NULL,"Return the cumulative distribution of latencies of a subset of commands or all.","server","7.0.0",.args=LATENCY_HISTOGRAM_Args,.numargs=1},
{"history",NULL,"Return timestamp-latency samples for the event.","server","2.8.13",.args=LATENCY_HISTORY_Args,.numargs=1},
{"latest",NULL,"Return the latest latency samples for all events.","server","2.8.13"},
{"reset",NULL,"Reset latency data for one or more events.","server","2.8.13",.args=LATENCY_RESET_Args,.numargs=1},
{0}
};

/********** LATENCY ********************/

/********** LOLWUT ********************/

/* LOLWUT argument table */
struct commandArg LOLWUT_Args[] = {
{"version",ARG_TYPE_INTEGER,"VERSION",NULL,1,0,0},
{0}
};

/********** MEMORY DOCTOR ********************/

/********** MEMORY HELP ********************/

/********** MEMORY MALLOC_STATS ********************/

/********** MEMORY PURGE ********************/

/********** MEMORY STATS ********************/

/********** MEMORY USAGE ********************/

/* MEMORY USAGE argument table */
struct commandArg MEMORY_USAGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,"SAMPLES",NULL,1,0,0},
{0}
};

/* MEMORY command table */
struct commandDocs MEMORY_Subcommands[] = {
{"doctor",NULL,"Outputs memory problems report","server","4.0.0"},
{"help",NULL,"Show helpful text about the different subcommands","server","4.0.0"},
{"malloc-stats",NULL,"Show allocator internal stats","server","4.0.0"},
{"purge",NULL,"Ask the allocator to release memory","server","4.0.0"},
{"stats",NULL,"Show memory usage details","server","4.0.0"},
{"usage",NULL,"Estimate the memory usage of a key","server","4.0.0",.args=MEMORY_USAGE_Args,.numargs=2},
{0}
};

/********** MEMORY ********************/

/********** MODULE HELP ********************/

/********** MODULE LIST ********************/

/********** MODULE LOAD ********************/

/* MODULE LOAD argument table */
struct commandArg MODULE_LOAD_Args[] = {
{"path",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"arg",ARG_TYPE_STRING,NULL,NULL,1,1,0},
{0}
};

/********** MODULE LOADEX ********************/

/* MODULE LOADEX configs argument table */
struct commandArg MODULE_LOADEX_configs_Subargs[] = {
{"name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* MODULE LOADEX args argument table */
struct commandArg MODULE_LOADEX_args_Subargs[] = {
{"arg",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* MODULE LOADEX argument table */
struct commandArg MODULE_LOADEX_Args[] = {
{"path",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"configs",ARG_TYPE_BLOCK,"CONFIG",NULL,1,1,1,.subargs=MODULE_LOADEX_configs_Subargs,.numsubargs=2},
{"args",ARG_TYPE_BLOCK,"ARGS",NULL,1,1,0,.subargs=MODULE_LOADEX_args_Subargs,.numsubargs=1},
{0}
};

/********** MODULE UNLOAD ********************/

/* MODULE UNLOAD argument table */
struct commandArg MODULE_UNLOAD_Args[] = {
{"name",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* MODULE command table */
struct commandDocs MODULE_Subcommands[] = {
{"help",NULL,"Show helpful text about the different subcommands","server","5.0.0"},
{"list",NULL,"List all modules loaded by the server","server","4.0.0"},
{"load",NULL,"Load a module","server","4.0.0",.args=MODULE_LOAD_Args,.numargs=2},
{"loadex",NULL,"Load a module with extended parameters","server","7.0.0",.args=MODULE_LOADEX_Args,.numargs=3},
{"unload",NULL,"Unload a module","server","4.0.0",.args=MODULE_UNLOAD_Args,.numargs=1},
{0}
};

/********** MODULE ********************/

/********** MONITOR ********************/

/********** PSYNC ********************/

/* PSYNC argument table */
struct commandArg PSYNC_Args[] = {
{"replicationid",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** REPLCONF ********************/

/********** REPLICAOF ********************/

/* REPLICAOF argument table */
struct commandArg REPLICAOF_Args[] = {
{"host",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** RESTORE_ASKING ********************/

/* RESTORE_ASKING argument table */
struct commandArg RESTORE_ASKING_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"ttl",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"serialized-value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"replace",ARG_TYPE_PURE_TOKEN,"REPLACE","3.0.0",1,0,0},
{"absttl",ARG_TYPE_PURE_TOKEN,"ABSTTL","5.0.0",1,0,0},
{"seconds",ARG_TYPE_INTEGER,"IDLETIME","5.0.0",1,0,0},
{"frequency",ARG_TYPE_INTEGER,"FREQ","5.0.0",1,0,0},
{0}
};

/********** ROLE ********************/

/********** SAVE ********************/

/********** SHUTDOWN ********************/

/* SHUTDOWN nosave_save argument table */
struct commandArg SHUTDOWN_nosave_save_Subargs[] = {
{"nosave",ARG_TYPE_PURE_TOKEN,"NOSAVE",NULL,0,0,0},
{"save",ARG_TYPE_PURE_TOKEN,"SAVE",NULL,0,0,0},
{0}
};

/* SHUTDOWN argument table */
struct commandArg SHUTDOWN_Args[] = {
{"nosave_save",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=SHUTDOWN_nosave_save_Subargs,.numsubargs=2},
{"now",ARG_TYPE_PURE_TOKEN,"NOW","7.0.0",1,0,0},
{"force",ARG_TYPE_PURE_TOKEN,"FORCE","7.0.0",1,0,0},
{"abort",ARG_TYPE_PURE_TOKEN,"ABORT","7.0.0",1,0,0},
{0}
};

/********** SLAVEOF ********************/

/* SLAVEOF argument table */
struct commandArg SLAVEOF_Args[] = {
{"host",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"port",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** SLOWLOG GET ********************/

/* SLOWLOG GET argument table */
struct commandArg SLOWLOG_GET_Args[] = {
{"count",ARG_TYPE_INTEGER,NULL,NULL,1,0,0},
{0}
};

/********** SLOWLOG HELP ********************/

/********** SLOWLOG LEN ********************/

/********** SLOWLOG RESET ********************/

/* SLOWLOG command table */
struct commandDocs SLOWLOG_Subcommands[] = {
{"get",NULL,"Get the slow log's entries","server","2.2.12",.args=SLOWLOG_GET_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","server","6.2.0"},
{"len",NULL,"Get the slow log's length","server","2.2.12"},
{"reset",NULL,"Clear all entries from the slow log","server","2.2.12"},
{0}
};

/********** SLOWLOG ********************/

/********** SWAPDB ********************/

/* SWAPDB argument table */
struct commandArg SWAPDB_Args[] = {
{"index1",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"index2",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** SYNC ********************/

/********** TIME ********************/

/********** SADD ********************/

/* SADD argument table */
struct commandArg SADD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SCARD ********************/

/* SCARD argument table */
struct commandArg SCARD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** SDIFF ********************/

/* SDIFF argument table */
struct commandArg SDIFF_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** SDIFFSTORE ********************/

/* SDIFFSTORE argument table */
struct commandArg SDIFFSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** SINTER ********************/

/* SINTER argument table */
struct commandArg SINTER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** SINTERCARD ********************/

/* SINTERCARD argument table */
struct commandArg SINTERCARD_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"limit",ARG_TYPE_INTEGER,"LIMIT",NULL,1,0,0},
{0}
};

/********** SINTERSTORE ********************/

/* SINTERSTORE argument table */
struct commandArg SINTERSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** SISMEMBER ********************/

/* SISMEMBER argument table */
struct commandArg SISMEMBER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SMEMBERS ********************/

/* SMEMBERS argument table */
struct commandArg SMEMBERS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** SMISMEMBER ********************/

/* SMISMEMBER argument table */
struct commandArg SMISMEMBER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SMOVE ********************/

/* SMOVE argument table */
struct commandArg SMOVE_Args[] = {
{"source",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SPOP ********************/

/* SPOP argument table */
struct commandArg SPOP_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,"3.2.0",1,0,0},
{0}
};

/********** SRANDMEMBER ********************/

/* SRANDMEMBER argument table */
struct commandArg SRANDMEMBER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,"2.6.0",1,0,0},
{0}
};

/********** SREM ********************/

/* SREM argument table */
struct commandArg SREM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** SSCAN ********************/

/* SSCAN argument table */
struct commandArg SSCAN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"cursor",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"MATCH",NULL,1,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** SUNION ********************/

/* SUNION argument table */
struct commandArg SUNION_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** SUNIONSTORE ********************/

/* SUNIONSTORE argument table */
struct commandArg SUNIONSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** BZMPOP ********************/

/* BZMPOP where argument table */
struct commandArg BZMPOP_where_Subargs[] = {
{"min",ARG_TYPE_PURE_TOKEN,"MIN",NULL,0,0,0},
{"max",ARG_TYPE_PURE_TOKEN,"MAX",NULL,0,0,0},
{0}
};

/* BZMPOP argument table */
struct commandArg BZMPOP_Args[] = {
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"where",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=BZMPOP_where_Subargs,.numsubargs=2},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** BZPOPMAX ********************/

/* BZPOPMAX argument table */
struct commandArg BZPOPMAX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** BZPOPMIN ********************/

/* BZPOPMIN argument table */
struct commandArg BZPOPMIN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"timeout",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** ZADD ********************/

/* ZADD condition argument table */
struct commandArg ZADD_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{0}
};

/* ZADD comparison argument table */
struct commandArg ZADD_comparison_Subargs[] = {
{"gt",ARG_TYPE_PURE_TOKEN,"GT",NULL,0,0,0},
{"lt",ARG_TYPE_PURE_TOKEN,"LT",NULL,0,0,0},
{0}
};

/* ZADD score_member argument table */
struct commandArg ZADD_score_member_Subargs[] = {
{"score",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* ZADD argument table */
struct commandArg ZADD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"3.0.2",1,0,0,.subargs=ZADD_condition_Subargs,.numsubargs=2},
{"comparison",ARG_TYPE_ONEOF,NULL,"6.2.0",1,0,0,.subargs=ZADD_comparison_Subargs,.numsubargs=2},
{"change",ARG_TYPE_PURE_TOKEN,"CH","3.0.2",1,0,0},
{"increment",ARG_TYPE_PURE_TOKEN,"INCR","3.0.2",1,0,0},
{"score_member",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=ZADD_score_member_Subargs,.numsubargs=2},
{0}
};

/********** ZCARD ********************/

/* ZCARD argument table */
struct commandArg ZCARD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** ZCOUNT ********************/

/* ZCOUNT argument table */
struct commandArg ZCOUNT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"max",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** ZDIFF ********************/

/* ZDIFF argument table */
struct commandArg ZDIFF_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{0}
};

/********** ZDIFFSTORE ********************/

/* ZDIFFSTORE argument table */
struct commandArg ZDIFFSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** ZINCRBY ********************/

/* ZINCRBY argument table */
struct commandArg ZINCRBY_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"increment",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ZINTER ********************/

/* ZINTER aggregate argument table */
struct commandArg ZINTER_aggregate_Subargs[] = {
{"sum",ARG_TYPE_PURE_TOKEN,"SUM",NULL,0,0,0},
{"min",ARG_TYPE_PURE_TOKEN,"MIN",NULL,0,0,0},
{"max",ARG_TYPE_PURE_TOKEN,"MAX",NULL,0,0,0},
{0}
};

/* ZINTER argument table */
struct commandArg ZINTER_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"weight",ARG_TYPE_INTEGER,"WEIGHTS",NULL,1,1,0},
{"aggregate",ARG_TYPE_ONEOF,"AGGREGATE",NULL,1,0,0,.subargs=ZINTER_aggregate_Subargs,.numsubargs=3},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{0}
};

/********** ZINTERCARD ********************/

/* ZINTERCARD argument table */
struct commandArg ZINTERCARD_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"limit",ARG_TYPE_INTEGER,"LIMIT",NULL,1,0,0},
{0}
};

/********** ZINTERSTORE ********************/

/* ZINTERSTORE aggregate argument table */
struct commandArg ZINTERSTORE_aggregate_Subargs[] = {
{"sum",ARG_TYPE_PURE_TOKEN,"SUM",NULL,0,0,0},
{"min",ARG_TYPE_PURE_TOKEN,"MIN",NULL,0,0,0},
{"max",ARG_TYPE_PURE_TOKEN,"MAX",NULL,0,0,0},
{0}
};

/* ZINTERSTORE argument table */
struct commandArg ZINTERSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"weight",ARG_TYPE_INTEGER,"WEIGHTS",NULL,1,1,0},
{"aggregate",ARG_TYPE_ONEOF,"AGGREGATE",NULL,1,0,0,.subargs=ZINTERSTORE_aggregate_Subargs,.numsubargs=3},
{0}
};

/********** ZLEXCOUNT ********************/

/* ZLEXCOUNT argument table */
struct commandArg ZLEXCOUNT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"max",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ZMPOP ********************/

/* ZMPOP where argument table */
struct commandArg ZMPOP_where_Subargs[] = {
{"min",ARG_TYPE_PURE_TOKEN,"MIN",NULL,0,0,0},
{"max",ARG_TYPE_PURE_TOKEN,"MAX",NULL,0,0,0},
{0}
};

/* ZMPOP argument table */
struct commandArg ZMPOP_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"where",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=ZMPOP_where_Subargs,.numsubargs=2},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** ZMSCORE ********************/

/* ZMSCORE argument table */
struct commandArg ZMSCORE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** ZPOPMAX ********************/

/* ZPOPMAX argument table */
struct commandArg ZPOPMAX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,1,0,0},
{0}
};

/********** ZPOPMIN ********************/

/* ZPOPMIN argument table */
struct commandArg ZPOPMIN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,1,0,0},
{0}
};

/********** ZRANDMEMBER ********************/

/* ZRANDMEMBER options argument table */
struct commandArg ZRANDMEMBER_options_Subargs[] = {
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{0}
};

/* ZRANDMEMBER argument table */
struct commandArg ZRANDMEMBER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"options",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=ZRANDMEMBER_options_Subargs,.numsubargs=2},
{0}
};

/********** ZRANGE ********************/

/* ZRANGE sortby argument table */
struct commandArg ZRANGE_sortby_Subargs[] = {
{"byscore",ARG_TYPE_PURE_TOKEN,"BYSCORE",NULL,0,0,0},
{"bylex",ARG_TYPE_PURE_TOKEN,"BYLEX",NULL,0,0,0},
{0}
};

/* ZRANGE offset_count argument table */
struct commandArg ZRANGE_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* ZRANGE argument table */
struct commandArg ZRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"max",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"sortby",ARG_TYPE_ONEOF,NULL,"6.2.0",1,0,0,.subargs=ZRANGE_sortby_Subargs,.numsubargs=2},
{"rev",ARG_TYPE_PURE_TOKEN,"REV","6.2.0",1,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT","6.2.0",1,0,0,.subargs=ZRANGE_offset_count_Subargs,.numsubargs=2},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{0}
};

/********** ZRANGEBYLEX ********************/

/* ZRANGEBYLEX offset_count argument table */
struct commandArg ZRANGEBYLEX_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* ZRANGEBYLEX argument table */
struct commandArg ZRANGEBYLEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"max",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=ZRANGEBYLEX_offset_count_Subargs,.numsubargs=2},
{0}
};

/********** ZRANGEBYSCORE ********************/

/* ZRANGEBYSCORE offset_count argument table */
struct commandArg ZRANGEBYSCORE_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* ZRANGEBYSCORE argument table */
struct commandArg ZRANGEBYSCORE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"max",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES","2.0.0",1,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=ZRANGEBYSCORE_offset_count_Subargs,.numsubargs=2},
{0}
};

/********** ZRANGESTORE ********************/

/* ZRANGESTORE sortby argument table */
struct commandArg ZRANGESTORE_sortby_Subargs[] = {
{"byscore",ARG_TYPE_PURE_TOKEN,"BYSCORE",NULL,0,0,0},
{"bylex",ARG_TYPE_PURE_TOKEN,"BYLEX",NULL,0,0,0},
{0}
};

/* ZRANGESTORE offset_count argument table */
struct commandArg ZRANGESTORE_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* ZRANGESTORE argument table */
struct commandArg ZRANGESTORE_Args[] = {
{"dst",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"src",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"max",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"sortby",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=ZRANGESTORE_sortby_Subargs,.numsubargs=2},
{"rev",ARG_TYPE_PURE_TOKEN,"REV",NULL,1,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=ZRANGESTORE_offset_count_Subargs,.numsubargs=2},
{0}
};

/********** ZRANK ********************/

/* ZRANK argument table */
struct commandArg ZRANK_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ZREM ********************/

/* ZREM argument table */
struct commandArg ZREM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** ZREMRANGEBYLEX ********************/

/* ZREMRANGEBYLEX argument table */
struct commandArg ZREMRANGEBYLEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"max",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ZREMRANGEBYRANK ********************/

/* ZREMRANGEBYRANK argument table */
struct commandArg ZREMRANGEBYRANK_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"stop",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** ZREMRANGEBYSCORE ********************/

/* ZREMRANGEBYSCORE argument table */
struct commandArg ZREMRANGEBYSCORE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"min",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"max",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** ZREVRANGE ********************/

/* ZREVRANGE argument table */
struct commandArg ZREVRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"stop",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{0}
};

/********** ZREVRANGEBYLEX ********************/

/* ZREVRANGEBYLEX offset_count argument table */
struct commandArg ZREVRANGEBYLEX_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* ZREVRANGEBYLEX argument table */
struct commandArg ZREVRANGEBYLEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"max",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"min",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=ZREVRANGEBYLEX_offset_count_Subargs,.numsubargs=2},
{0}
};

/********** ZREVRANGEBYSCORE ********************/

/* ZREVRANGEBYSCORE offset_count argument table */
struct commandArg ZREVRANGEBYSCORE_offset_count_Subargs[] = {
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/* ZREVRANGEBYSCORE argument table */
struct commandArg ZREVRANGEBYSCORE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"max",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"min",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{"offset_count",ARG_TYPE_BLOCK,"LIMIT",NULL,1,0,0,.subargs=ZREVRANGEBYSCORE_offset_count_Subargs,.numsubargs=2},
{0}
};

/********** ZREVRANK ********************/

/* ZREVRANK argument table */
struct commandArg ZREVRANK_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ZSCAN ********************/

/* ZSCAN argument table */
struct commandArg ZSCAN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"cursor",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"pattern",ARG_TYPE_PATTERN,"MATCH",NULL,1,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** ZSCORE ********************/

/* ZSCORE argument table */
struct commandArg ZSCORE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"member",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** ZUNION ********************/

/* ZUNION aggregate argument table */
struct commandArg ZUNION_aggregate_Subargs[] = {
{"sum",ARG_TYPE_PURE_TOKEN,"SUM",NULL,0,0,0},
{"min",ARG_TYPE_PURE_TOKEN,"MIN",NULL,0,0,0},
{"max",ARG_TYPE_PURE_TOKEN,"MAX",NULL,0,0,0},
{0}
};

/* ZUNION argument table */
struct commandArg ZUNION_Args[] = {
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"weight",ARG_TYPE_INTEGER,"WEIGHTS",NULL,1,1,0},
{"aggregate",ARG_TYPE_ONEOF,"AGGREGATE",NULL,1,0,0,.subargs=ZUNION_aggregate_Subargs,.numsubargs=3},
{"withscores",ARG_TYPE_PURE_TOKEN,"WITHSCORES",NULL,1,0,0},
{0}
};

/********** ZUNIONSTORE ********************/

/* ZUNIONSTORE aggregate argument table */
struct commandArg ZUNIONSTORE_aggregate_Subargs[] = {
{"sum",ARG_TYPE_PURE_TOKEN,"SUM",NULL,0,0,0},
{"min",ARG_TYPE_PURE_TOKEN,"MIN",NULL,0,0,0},
{"max",ARG_TYPE_PURE_TOKEN,"MAX",NULL,0,0,0},
{0}
};

/* ZUNIONSTORE argument table */
struct commandArg ZUNIONSTORE_Args[] = {
{"destination",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"numkeys",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"weight",ARG_TYPE_INTEGER,"WEIGHTS",NULL,1,1,0},
{"aggregate",ARG_TYPE_ONEOF,"AGGREGATE",NULL,1,0,0,.subargs=ZUNIONSTORE_aggregate_Subargs,.numsubargs=3},
{0}
};

/********** XACK ********************/

/* XACK argument table */
struct commandArg XACK_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"group",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"id",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** XADD ********************/

/* XADD trim strategy argument table */
struct commandArg XADD_trim_strategy_Subargs[] = {
{"maxlen",ARG_TYPE_PURE_TOKEN,"MAXLEN",NULL,0,0,0},
{"minid",ARG_TYPE_PURE_TOKEN,"MINID","6.2.0",0,0,0},
{0}
};

/* XADD trim operator argument table */
struct commandArg XADD_trim_operator_Subargs[] = {
{"equal",ARG_TYPE_PURE_TOKEN,"=",NULL,0,0,0},
{"approximately",ARG_TYPE_PURE_TOKEN,"~",NULL,0,0,0},
{0}
};

/* XADD trim argument table */
struct commandArg XADD_trim_Subargs[] = {
{"strategy",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=XADD_trim_strategy_Subargs,.numsubargs=2},
{"operator",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=XADD_trim_operator_Subargs,.numsubargs=2},
{"threshold",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,"LIMIT","6.2.0",1,0,0},
{0}
};

/* XADD id_or_auto argument table */
struct commandArg XADD_id_or_auto_Subargs[] = {
{"auto_id",ARG_TYPE_PURE_TOKEN,"*",NULL,0,0,0},
{"id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* XADD field_value argument table */
struct commandArg XADD_field_value_Subargs[] = {
{"field",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* XADD argument table */
struct commandArg XADD_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"nomkstream",ARG_TYPE_PURE_TOKEN,"NOMKSTREAM","6.2.0",1,0,0},
{"trim",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=XADD_trim_Subargs,.numsubargs=4},
{"id_or_auto",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=XADD_id_or_auto_Subargs,.numsubargs=2},
{"field_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=XADD_field_value_Subargs,.numsubargs=2},
{0}
};

/********** XAUTOCLAIM ********************/

/* XAUTOCLAIM argument table */
struct commandArg XAUTOCLAIM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"group",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"consumer",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"min-idle-time",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"start",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{"justid",ARG_TYPE_PURE_TOKEN,"JUSTID",NULL,1,0,0},
{0}
};

/********** XCLAIM ********************/

/* XCLAIM argument table */
struct commandArg XCLAIM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"group",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"consumer",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"min-idle-time",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"id",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{"ms",ARG_TYPE_INTEGER,"IDLE",NULL,1,0,0},
{"unix-time-milliseconds",ARG_TYPE_UNIX_TIME,"TIME",NULL,1,0,0},
{"count",ARG_TYPE_INTEGER,"RETRYCOUNT",NULL,1,0,0},
{"force",ARG_TYPE_PURE_TOKEN,"FORCE",NULL,1,0,0},
{"justid",ARG_TYPE_PURE_TOKEN,"JUSTID",NULL,1,0,0},
{0}
};

/********** XDEL ********************/

/* XDEL argument table */
struct commandArg XDEL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"id",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/********** XGROUP CREATE ********************/

/* XGROUP CREATE id argument table */
struct commandArg XGROUP_CREATE_id_Subargs[] = {
{"id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"new_id",ARG_TYPE_PURE_TOKEN,"$",NULL,0,0,0},
{0}
};

/* XGROUP CREATE argument table */
struct commandArg XGROUP_CREATE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"groupname",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"id",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=XGROUP_CREATE_id_Subargs,.numsubargs=2},
{"mkstream",ARG_TYPE_PURE_TOKEN,"MKSTREAM",NULL,1,0,0},
{"entries_read",ARG_TYPE_INTEGER,"ENTRIESREAD",NULL,1,0,0},
{0}
};

/********** XGROUP CREATECONSUMER ********************/

/* XGROUP CREATECONSUMER argument table */
struct commandArg XGROUP_CREATECONSUMER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"groupname",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"consumername",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** XGROUP DELCONSUMER ********************/

/* XGROUP DELCONSUMER argument table */
struct commandArg XGROUP_DELCONSUMER_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"groupname",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"consumername",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** XGROUP DESTROY ********************/

/* XGROUP DESTROY argument table */
struct commandArg XGROUP_DESTROY_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"groupname",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** XGROUP HELP ********************/

/********** XGROUP SETID ********************/

/* XGROUP SETID id argument table */
struct commandArg XGROUP_SETID_id_Subargs[] = {
{"id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"new_id",ARG_TYPE_PURE_TOKEN,"$",NULL,0,0,0},
{0}
};

/* XGROUP SETID argument table */
struct commandArg XGROUP_SETID_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"groupname",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"id",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=XGROUP_SETID_id_Subargs,.numsubargs=2},
{"entries_read",ARG_TYPE_INTEGER,"ENTRIESREAD",NULL,1,0,0},
{0}
};

/* XGROUP command table */
struct commandDocs XGROUP_Subcommands[] = {
{"create",NULL,"Create a consumer group.","stream","5.0.0",.args=XGROUP_CREATE_Args,.numargs=5},
{"createconsumer",NULL,"Create a consumer in a consumer group.","stream","6.2.0",.args=XGROUP_CREATECONSUMER_Args,.numargs=3},
{"delconsumer",NULL,"Delete a consumer from a consumer group.","stream","5.0.0",.args=XGROUP_DELCONSUMER_Args,.numargs=3},
{"destroy",NULL,"Destroy a consumer group.","stream","5.0.0",.args=XGROUP_DESTROY_Args,.numargs=2},
{"help",NULL,"Show helpful text about the different subcommands","stream","5.0.0"},
{"setid",NULL,"Set a consumer group to an arbitrary last delivered ID value.","stream","5.0.0",.args=XGROUP_SETID_Args,.numargs=4},
{0}
};

/********** XGROUP ********************/

/********** XINFO CONSUMERS ********************/

/* XINFO CONSUMERS argument table */
struct commandArg XINFO_CONSUMERS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"groupname",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** XINFO GROUPS ********************/

/* XINFO GROUPS argument table */
struct commandArg XINFO_GROUPS_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** XINFO HELP ********************/

/********** XINFO STREAM ********************/

/* XINFO STREAM full argument table */
struct commandArg XINFO_STREAM_full_Subargs[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/* XINFO STREAM argument table */
struct commandArg XINFO_STREAM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"full",ARG_TYPE_BLOCK,"FULL",NULL,1,0,0,.subargs=XINFO_STREAM_full_Subargs,.numsubargs=1},
{0}
};

/* XINFO command table */
struct commandDocs XINFO_Subcommands[] = {
{"consumers",NULL,"List the consumers in a consumer group","stream","5.0.0",.args=XINFO_CONSUMERS_Args,.numargs=2},
{"groups",NULL,"List the consumer groups of a stream","stream","5.0.0",.args=XINFO_GROUPS_Args,.numargs=1},
{"help",NULL,"Show helpful text about the different subcommands","stream","5.0.0"},
{"stream",NULL,"Get information about a stream","stream","5.0.0",.args=XINFO_STREAM_Args,.numargs=2},
{0}
};

/********** XINFO ********************/

/********** XLEN ********************/

/* XLEN argument table */
struct commandArg XLEN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** XPENDING ********************/

/* XPENDING filters argument table */
struct commandArg XPENDING_filters_Subargs[] = {
{"min-idle-time",ARG_TYPE_INTEGER,"IDLE","6.2.0",1,0,0},
{"start",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"end",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"consumer",ARG_TYPE_STRING,NULL,NULL,1,0,0},
{0}
};

/* XPENDING argument table */
struct commandArg XPENDING_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"group",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"filters",ARG_TYPE_BLOCK,NULL,NULL,1,0,0,.subargs=XPENDING_filters_Subargs,.numsubargs=5},
{0}
};

/********** XRANGE ********************/

/* XRANGE argument table */
struct commandArg XRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"end",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** XREAD ********************/

/* XREAD streams argument table */
struct commandArg XREAD_streams_Subargs[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"id",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/* XREAD argument table */
struct commandArg XREAD_Args[] = {
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{"milliseconds",ARG_TYPE_INTEGER,"BLOCK",NULL,1,0,0},
{"streams",ARG_TYPE_BLOCK,"STREAMS",NULL,0,0,0,.subargs=XREAD_streams_Subargs,.numsubargs=2},
{0}
};

/********** XREADGROUP ********************/

/* XREADGROUP group_consumer argument table */
struct commandArg XREADGROUP_group_consumer_Subargs[] = {
{"group",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"consumer",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* XREADGROUP streams argument table */
struct commandArg XREADGROUP_streams_Subargs[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{"id",ARG_TYPE_STRING,NULL,NULL,0,1,0},
{0}
};

/* XREADGROUP argument table */
struct commandArg XREADGROUP_Args[] = {
{"group_consumer",ARG_TYPE_BLOCK,"GROUP",NULL,0,0,0,.subargs=XREADGROUP_group_consumer_Subargs,.numsubargs=2},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{"milliseconds",ARG_TYPE_INTEGER,"BLOCK",NULL,1,0,0},
{"noack",ARG_TYPE_PURE_TOKEN,"NOACK",NULL,1,0,0},
{"streams",ARG_TYPE_BLOCK,"STREAMS",NULL,0,0,0,.subargs=XREADGROUP_streams_Subargs,.numsubargs=2},
{0}
};

/********** XREVRANGE ********************/

/* XREVRANGE argument table */
struct commandArg XREVRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"end",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"start",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,"COUNT",NULL,1,0,0},
{0}
};

/********** XSETID ********************/

/* XSETID argument table */
struct commandArg XSETID_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"last-id",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"entries_added",ARG_TYPE_INTEGER,"ENTRIESADDED",NULL,1,0,0},
{"max_deleted_entry_id",ARG_TYPE_STRING,"MAXDELETEDID",NULL,1,0,0},
{0}
};

/********** XTRIM ********************/

/* XTRIM trim strategy argument table */
struct commandArg XTRIM_trim_strategy_Subargs[] = {
{"maxlen",ARG_TYPE_PURE_TOKEN,"MAXLEN",NULL,0,0,0},
{"minid",ARG_TYPE_PURE_TOKEN,"MINID","6.2.0",0,0,0},
{0}
};

/* XTRIM trim operator argument table */
struct commandArg XTRIM_trim_operator_Subargs[] = {
{"equal",ARG_TYPE_PURE_TOKEN,"=",NULL,0,0,0},
{"approximately",ARG_TYPE_PURE_TOKEN,"~",NULL,0,0,0},
{0}
};

/* XTRIM trim argument table */
struct commandArg XTRIM_trim_Subargs[] = {
{"strategy",ARG_TYPE_ONEOF,NULL,NULL,0,0,0,.subargs=XTRIM_trim_strategy_Subargs,.numsubargs=2},
{"operator",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=XTRIM_trim_operator_Subargs,.numsubargs=2},
{"threshold",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"count",ARG_TYPE_INTEGER,"LIMIT","6.2.0",1,0,0},
{0}
};

/* XTRIM argument table */
struct commandArg XTRIM_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"trim",ARG_TYPE_BLOCK,NULL,NULL,0,0,0,.subargs=XTRIM_trim_Subargs,.numsubargs=4},
{0}
};

/********** APPEND ********************/

/* APPEND argument table */
struct commandArg APPEND_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** DECR ********************/

/* DECR argument table */
struct commandArg DECR_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** DECRBY ********************/

/* DECRBY argument table */
struct commandArg DECRBY_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"decrement",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** GET ********************/

/* GET argument table */
struct commandArg GET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** GETDEL ********************/

/* GETDEL argument table */
struct commandArg GETDEL_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** GETEX ********************/

/* GETEX expiration argument table */
struct commandArg GETEX_expiration_Subargs[] = {
{"seconds",ARG_TYPE_INTEGER,"EX",NULL,0,0,0},
{"milliseconds",ARG_TYPE_INTEGER,"PX",NULL,0,0,0},
{"unix-time-seconds",ARG_TYPE_UNIX_TIME,"EXAT",NULL,0,0,0},
{"unix-time-milliseconds",ARG_TYPE_UNIX_TIME,"PXAT",NULL,0,0,0},
{"persist",ARG_TYPE_PURE_TOKEN,"PERSIST",NULL,0,0,0},
{0}
};

/* GETEX argument table */
struct commandArg GETEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"expiration",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=GETEX_expiration_Subargs,.numsubargs=5},
{0}
};

/********** GETRANGE ********************/

/* GETRANGE argument table */
struct commandArg GETRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"end",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** GETSET ********************/

/* GETSET argument table */
struct commandArg GETSET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** INCR ********************/

/* INCR argument table */
struct commandArg INCR_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** INCRBY ********************/

/* INCRBY argument table */
struct commandArg INCRBY_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"increment",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** INCRBYFLOAT ********************/

/* INCRBYFLOAT argument table */
struct commandArg INCRBYFLOAT_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"increment",ARG_TYPE_DOUBLE,NULL,NULL,0,0,0},
{0}
};

/********** LCS ********************/

/* LCS argument table */
struct commandArg LCS_Args[] = {
{"key1",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"key2",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"len",ARG_TYPE_PURE_TOKEN,"LEN",NULL,1,0,0},
{"idx",ARG_TYPE_PURE_TOKEN,"IDX",NULL,1,0,0},
{"len",ARG_TYPE_INTEGER,"MINMATCHLEN",NULL,1,0,0},
{"withmatchlen",ARG_TYPE_PURE_TOKEN,"WITHMATCHLEN",NULL,1,0,0},
{0}
};

/********** MGET ********************/

/* MGET argument table */
struct commandArg MGET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/********** MSET ********************/

/* MSET key_value argument table */
struct commandArg MSET_key_value_Subargs[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* MSET argument table */
struct commandArg MSET_Args[] = {
{"key_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=MSET_key_value_Subargs,.numsubargs=2},
{0}
};

/********** MSETNX ********************/

/* MSETNX key_value argument table */
struct commandArg MSETNX_key_value_Subargs[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/* MSETNX argument table */
struct commandArg MSETNX_Args[] = {
{"key_value",ARG_TYPE_BLOCK,NULL,NULL,0,1,0,.subargs=MSETNX_key_value_Subargs,.numsubargs=2},
{0}
};

/********** PSETEX ********************/

/* PSETEX argument table */
struct commandArg PSETEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"milliseconds",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SET ********************/

/* SET condition argument table */
struct commandArg SET_condition_Subargs[] = {
{"nx",ARG_TYPE_PURE_TOKEN,"NX",NULL,0,0,0},
{"xx",ARG_TYPE_PURE_TOKEN,"XX",NULL,0,0,0},
{0}
};

/* SET expiration argument table */
struct commandArg SET_expiration_Subargs[] = {
{"seconds",ARG_TYPE_INTEGER,"EX","2.6.12",0,0,0},
{"milliseconds",ARG_TYPE_INTEGER,"PX","2.6.12",0,0,0},
{"unix-time-seconds",ARG_TYPE_UNIX_TIME,"EXAT","6.2.0",0,0,0},
{"unix-time-milliseconds",ARG_TYPE_UNIX_TIME,"PXAT","6.2.0",0,0,0},
{"keepttl",ARG_TYPE_PURE_TOKEN,"KEEPTTL","6.0.0",0,0,0},
{0}
};

/* SET argument table */
struct commandArg SET_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{"condition",ARG_TYPE_ONEOF,NULL,"2.6.12",1,0,0,.subargs=SET_condition_Subargs,.numsubargs=2},
{"get",ARG_TYPE_PURE_TOKEN,"GET","6.2.0",1,0,0},
{"expiration",ARG_TYPE_ONEOF,NULL,NULL,1,0,0,.subargs=SET_expiration_Subargs,.numsubargs=5},
{0}
};

/********** SETEX ********************/

/* SETEX argument table */
struct commandArg SETEX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"seconds",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SETNX ********************/

/* SETNX argument table */
struct commandArg SETNX_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** SETRANGE ********************/

/* SETRANGE argument table */
struct commandArg SETRANGE_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"offset",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"value",ARG_TYPE_STRING,NULL,NULL,0,0,0},
{0}
};

/********** STRLEN ********************/

/* STRLEN argument table */
struct commandArg STRLEN_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{0}
};

/********** SUBSTR ********************/

/* SUBSTR argument table */
struct commandArg SUBSTR_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,0,0},
{"start",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{"end",ARG_TYPE_INTEGER,NULL,NULL,0,0,0},
{0}
};

/********** DISCARD ********************/

/********** EXEC ********************/

/********** MULTI ********************/

/********** UNWATCH ********************/

/********** WATCH ********************/

/* WATCH argument table */
struct commandArg WATCH_Args[] = {
{"key",ARG_TYPE_KEY,NULL,NULL,0,1,0},
{0}
};

/* Main command table */
struct commandDocs cliCommandDocs[] = {
/* bitmap */
{"bitcount",NULL,"Count set bits in a string","bitmap","2.6.0",.args=BITCOUNT_Args,.numargs=2},
{"bitfield",NULL,"Perform arbitrary bitfield integer operations on strings","bitmap","3.2.0",.args=BITFIELD_Args,.numargs=2},
{"bitfield_ro",NULL,"Perform arbitrary bitfield integer operations on strings. Read-only variant of BITFIELD","bitmap","6.0.0",.args=BITFIELD_RO_Args,.numargs=2},
{"bitop",NULL,"Perform bitwise operations between strings","bitmap","2.6.0",.args=BITOP_Args,.numargs=3},
{"bitpos",NULL,"Find first bit set or clear in a string","bitmap","2.8.7",.args=BITPOS_Args,.numargs=3},
{"getbit",NULL,"Returns the bit value at offset in the string value stored at key","bitmap","2.2.0",.args=GETBIT_Args,.numargs=2},
{"setbit",NULL,"Sets or clears the bit at offset in the string value stored at key","bitmap","2.2.0",.args=SETBIT_Args,.numargs=3},
/* cluster */
{"asking",NULL,"Sent by cluster clients after an -ASK redirect","cluster","3.0.0"},
{"cluster",NULL,"A container for cluster commands","cluster","3.0.0",.subcommands=CLUSTER_Subcommands},
{"readonly",NULL,"Enables read queries for a connection to a cluster replica node","cluster","3.0.0"},
{"readwrite",NULL,"Disables read queries for a connection to a cluster replica node","cluster","3.0.0"},
/* connection */
{"auth",NULL,"Authenticate to the server","connection","1.0.0",.args=AUTH_Args,.numargs=2},
{"client",NULL,"A container for client connection commands","connection","2.4.0",.subcommands=CLIENT_Subcommands},
{"echo",NULL,"Echo the given string","connection","1.0.0",.args=ECHO_Args,.numargs=1},
{"hello",NULL,"Handshake with Redis","connection","6.0.0",.args=HELLO_Args,.numargs=1},
{"ping",NULL,"Ping the server","connection","1.0.0",.args=PING_Args,.numargs=1},
{"quit",NULL,"Close the connection","connection","1.0.0"},
{"reset",NULL,"Reset the connection","connection","6.2.0"},
{"select",NULL,"Change the selected database for the current connection","connection","1.0.0",.args=SELECT_Args,.numargs=1},
/* generic */
{"copy",NULL,"Copy a key","generic","6.2.0",.args=COPY_Args,.numargs=4},
{"del",NULL,"Delete a key","generic","1.0.0",.args=DEL_Args,.numargs=1},
{"dump",NULL,"Return a serialized version of the value stored at the specified key.","generic","2.6.0",.args=DUMP_Args,.numargs=1},
{"exists",NULL,"Determine if a key exists","generic","1.0.0",.args=EXISTS_Args,.numargs=1},
{"expire",NULL,"Set a key's time to live in seconds","generic","1.0.0",.args=EXPIRE_Args,.numargs=3},
{"expireat",NULL,"Set the expiration for a key as a UNIX timestamp","generic","1.2.0",.args=EXPIREAT_Args,.numargs=3},
{"expiretime",NULL,"Get the expiration Unix timestamp for a key","generic","7.0.0",.args=EXPIRETIME_Args,.numargs=1},
{"keys",NULL,"Find all keys matching the given pattern","generic","1.0.0",.args=KEYS_Args,.numargs=1},
{"migrate",NULL,"Atomically transfer a key from a Redis instance to another one.","generic","2.6.0",.args=MIGRATE_Args,.numargs=9},
{"move",NULL,"Move a key to another database","generic","1.0.0",.args=MOVE_Args,.numargs=2},
{"object",NULL,"A container for object introspection commands","generic","2.2.3",.subcommands=OBJECT_Subcommands},
{"persist",NULL,"Remove the expiration from a key","generic","2.2.0",.args=PERSIST_Args,.numargs=1},
{"pexpire",NULL,"Set a key's time to live in milliseconds","generic","2.6.0",.args=PEXPIRE_Args,.numargs=3},
{"pexpireat",NULL,"Set the expiration for a key as a UNIX timestamp specified in milliseconds","generic","2.6.0",.args=PEXPIREAT_Args,.numargs=3},
{"pexpiretime",NULL,"Get the expiration Unix timestamp for a key in milliseconds","generic","7.0.0",.args=PEXPIRETIME_Args,.numargs=1},
{"pttl",NULL,"Get the time to live for a key in milliseconds","generic","2.6.0",.args=PTTL_Args,.numargs=1},
{"randomkey",NULL,"Return a random key from the keyspace","generic","1.0.0"},
{"rename",NULL,"Rename a key","generic","1.0.0",.args=RENAME_Args,.numargs=2},
{"renamenx",NULL,"Rename a key, only if the new key does not exist","generic","1.0.0",.args=RENAMENX_Args,.numargs=2},
{"restore",NULL,"Create a key using the provided serialized value, previously obtained using DUMP.","generic","2.6.0",.args=RESTORE_Args,.numargs=7},
{"scan",NULL,"Incrementally iterate the keys space","generic","2.8.0",.args=SCAN_Args,.numargs=4},
{"sort",NULL,"Sort the elements in a list, set or sorted set","generic","1.0.0",.args=SORT_Args,.numargs=7},
{"sort_ro",NULL,"Sort the elements in a list, set or sorted set. Read-only variant of SORT.","generic","7.0.0",.args=SORT_RO_Args,.numargs=6},
{"touch",NULL,"Alters the last access time of a key(s). Returns the number of existing keys specified.","generic","3.2.1",.args=TOUCH_Args,.numargs=1},
{"ttl",NULL,"Get the time to live for a key in seconds","generic","1.0.0",.args=TTL_Args,.numargs=1},
{"type",NULL,"Determine the type stored at key","generic","1.0.0",.args=TYPE_Args,.numargs=1},
{"unlink",NULL,"Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.","generic","4.0.0",.args=UNLINK_Args,.numargs=1},
{"wait",NULL,"Wait for the synchronous replication of all the write commands sent in the context of the current connection","generic","3.0.0",.args=WAIT_Args,.numargs=2},
/* geo */
{"geoadd",NULL,"Add one or more geospatial items in the geospatial index represented using a sorted set","geo","3.2.0",.args=GEOADD_Args,.numargs=4},
{"geodist",NULL,"Returns the distance between two members of a geospatial index","geo","3.2.0",.args=GEODIST_Args,.numargs=4},
{"geohash",NULL,"Returns members of a geospatial index as standard geohash strings","geo","3.2.0",.args=GEOHASH_Args,.numargs=2},
{"geopos",NULL,"Returns longitude and latitude of members of a geospatial index","geo","3.2.0",.args=GEOPOS_Args,.numargs=2},
{"georadius",NULL,"Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point","geo","3.2.0",.args=GEORADIUS_Args,.numargs=12},
{"georadiusbymember",NULL,"Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member","geo","3.2.0",.args=GEORADIUSBYMEMBER_Args,.numargs=11},
{"georadiusbymember_ro",NULL,"A read-only variant for GEORADIUSBYMEMBER","geo","3.2.10",.args=GEORADIUSBYMEMBER_RO_Args,.numargs=9},
{"georadius_ro",NULL,"A read-only variant for GEORADIUS","geo","3.2.10",.args=GEORADIUS_RO_Args,.numargs=10},
{"geosearch",NULL,"Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.","geo","6.2.0",.args=GEOSEARCH_Args,.numargs=8},
{"geosearchstore",NULL,"Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.","geo","6.2.0",.args=GEOSEARCHSTORE_Args,.numargs=7},
/* hash */
{"hdel",NULL,"Delete one or more hash fields","hash","2.0.0",.args=HDEL_Args,.numargs=2},
{"hexists",NULL,"Determine if a hash field exists","hash","2.0.0",.args=HEXISTS_Args,.numargs=2},
{"hget",NULL,"Get the value of a hash field","hash","2.0.0",.args=HGET_Args,.numargs=2},
{"hgetall",NULL,"Get all the fields and values in a hash","hash","2.0.0",.args=HGETALL_Args,.numargs=1},
{"hincrby",NULL,"Increment the integer value of a hash field by the given number","hash","2.0.0",.args=HINCRBY_Args,.numargs=3},
{"hincrbyfloat",NULL,"Increment the float value of a hash field by the given amount","hash","2.6.0",.args=HINCRBYFLOAT_Args,.numargs=3},
{"hkeys",NULL,"Get all the fields in a hash","hash","2.0.0",.args=HKEYS_Args,.numargs=1},
{"hlen",NULL,"Get the number of fields in a hash","hash","2.0.0",.args=HLEN_Args,.numargs=1},
{"hmget",NULL,"Get the values of all the given hash fields","hash","2.0.0",.args=HMGET_Args,.numargs=2},
{"hmset",NULL,"Set multiple hash fields to multiple values","hash","2.0.0",.args=HMSET_Args,.numargs=2},
{"hrandfield",NULL,"Get one or multiple random fields from a hash","hash","6.2.0",.args=HRANDFIELD_Args,.numargs=2},
{"hscan",NULL,"Incrementally iterate hash fields and associated values","hash","2.8.0",.args=HSCAN_Args,.numargs=4},
{"hset",NULL,"Set the string value of a hash field","hash","2.0.0",.args=HSET_Args,.numargs=2},
{"hsetnx",NULL,"Set the value of a hash field, only if the field does not exist","hash","2.0.0",.args=HSETNX_Args,.numargs=3},
{"hstrlen",NULL,"Get the length of the value of a hash field","hash","3.2.0",.args=HSTRLEN_Args,.numargs=2},
{"hvals",NULL,"Get all the values in a hash","hash","2.0.0",.args=HVALS_Args,.numargs=1},
/* hyperloglog */
{"pfadd",NULL,"Adds the specified elements to the specified HyperLogLog.","hyperloglog","2.8.9",.args=PFADD_Args,.numargs=2},
{"pfcount",NULL,"Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).","hyperloglog","2.8.9",.args=PFCOUNT_Args,.numargs=1},
{"pfdebug",NULL,"Internal commands for debugging HyperLogLog values","hyperloglog","2.8.9",.args=PFDEBUG_Args,.numargs=2},
{"pfmerge",NULL,"Merge N different HyperLogLogs into a single one.","hyperloglog","2.8.9",.args=PFMERGE_Args,.numargs=2},
{"pfselftest",NULL,"An internal command for testing HyperLogLog values","hyperloglog","2.8.9"},
/* list */
{"blmove",NULL,"Pop an element from a list, push it to another list and return it; or block until one is available","list","6.2.0",.args=BLMOVE_Args,.numargs=5},
{"blmpop",NULL,"Pop elements from a list, or block until one is available","list","7.0.0",.args=BLMPOP_Args,.numargs=5},
{"blpop",NULL,"Remove and get the first element in a list, or block until one is available","list","2.0.0",.args=BLPOP_Args,.numargs=2},
{"brpop",NULL,"Remove and get the last element in a list, or block until one is available","list","2.0.0",.args=BRPOP_Args,.numargs=2},
{"brpoplpush",NULL,"Pop an element from a list, push it to another list and return it; or block until one is available","list","2.2.0",.args=BRPOPLPUSH_Args,.numargs=3},
{"lindex",NULL,"Get an element from a list by its index","list","1.0.0",.args=LINDEX_Args,.numargs=2},
{"linsert",NULL,"Insert an element before or after another element in a list","list","2.2.0",.args=LINSERT_Args,.numargs=4},
{"llen",NULL,"Get the length of a list","list","1.0.0",.args=LLEN_Args,.numargs=1},
{"lmove",NULL,"Pop an element from a list, push it to another list and return it","list","6.2.0",.args=LMOVE_Args,.numargs=4},
{"lmpop",NULL,"Pop elements from a list","list","7.0.0",.args=LMPOP_Args,.numargs=4},
{"lpop",NULL,"Remove and get the first elements in a list","list","1.0.0",.args=LPOP_Args,.numargs=2},
{"lpos",NULL,"Return the index of matching elements on a list","list","6.0.6",.args=LPOS_Args,.numargs=5},
{"lpush",NULL,"Prepend one or multiple elements to a list","list","1.0.0",.args=LPUSH_Args,.numargs=2},
{"lpushx",NULL,"Prepend an element to a list, only if the list exists","list","2.2.0",.args=LPUSHX_Args,.numargs=2},
{"lrange",NULL,"Get a range of elements from a list","list","1.0.0",.args=LRANGE_Args,.numargs=3},
{"lrem",NULL,"Remove elements from a list","list","1.0.0",.args=LREM_Args,.numargs=3},
{"lset",NULL,"Set the value of an element in a list by its index","list","1.0.0",.args=LSET_Args,.numargs=3},
{"ltrim",NULL,"Trim a list to the specified range","list","1.0.0",.args=LTRIM_Args,.numargs=3},
{"rpop",NULL,"Remove and get the last elements in a list","list","1.0.0",.args=RPOP_Args,.numargs=2},
{"rpoplpush",NULL,"Remove the last element in a list, prepend it to another list and return it","list","1.2.0",.args=RPOPLPUSH_Args,.numargs=2},
{"rpush",NULL,"Append one or multiple elements to a list","list","1.0.0",.args=RPUSH_Args,.numargs=2},
{"rpushx",NULL,"Append an element to a list, only if the list exists","list","2.2.0",.args=RPUSHX_Args,.numargs=2},
/* pubsub */
{"psubscribe",NULL,"Listen for messages published to channels matching the given patterns","pubsub","2.0.0",.args=PSUBSCRIBE_Args,.numargs=1},
{"publish",NULL,"Post a message to a channel","pubsub","2.0.0",.args=PUBLISH_Args,.numargs=2},
{"pubsub",NULL,"A container for Pub/Sub commands","pubsub","2.8.0",.subcommands=PUBSUB_Subcommands},
{"punsubscribe",NULL,"Stop listening for messages posted to channels matching the given patterns","pubsub","2.0.0",.args=PUNSUBSCRIBE_Args,.numargs=1},
{"spublish",NULL,"Post a message to a shard channel","pubsub","7.0.0",.args=SPUBLISH_Args,.numargs=2},
{"ssubscribe",NULL,"Listen for messages published to the given shard channels","pubsub","7.0.0",.args=SSUBSCRIBE_Args,.numargs=1},
{"subscribe",NULL,"Listen for messages published to the given channels","pubsub","2.0.0",.args=SUBSCRIBE_Args,.numargs=1},
{"sunsubscribe",NULL,"Stop listening for messages posted to the given shard channels","pubsub","7.0.0",.args=SUNSUBSCRIBE_Args,.numargs=1},
{"unsubscribe",NULL,"Stop listening for messages posted to the given channels","pubsub","2.0.0",.args=UNSUBSCRIBE_Args,.numargs=1},
/* scripting */
{"eval",NULL,"Execute a Lua script server side","scripting","2.6.0",.args=EVAL_Args,.numargs=4},
{"evalsha",NULL,"Execute a Lua script server side","scripting","2.6.0",.args=EVALSHA_Args,.numargs=4},
{"evalsha_ro",NULL,"Execute a read-only Lua script server side","scripting","7.0.0",.args=EVALSHA_RO_Args,.numargs=4},
{"eval_ro",NULL,"Execute a read-only Lua script server side","scripting","7.0.0",.args=EVAL_RO_Args,.numargs=4},
{"fcall",NULL,"Invoke a function","scripting","7.0.0",.args=FCALL_Args,.numargs=4},
{"fcall_ro",NULL,"Invoke a read-only function","scripting","7.0.0",.args=FCALL_RO_Args,.numargs=4},
{"function",NULL,"A container for function commands","scripting","7.0.0",.subcommands=FUNCTION_Subcommands},
{"script",NULL,"A container for Lua scripts management commands","scripting","2.6.0",.subcommands=SCRIPT_Subcommands},
/* sentinel */
{"sentinel",NULL,"A container for Sentinel commands","sentinel","2.8.4",.subcommands=SENTINEL_Subcommands},
/* server */
{"acl",NULL,"A container for Access List Control commands ","server","6.0.0",.subcommands=ACL_Subcommands},
{"bgrewriteaof",NULL,"Asynchronously rewrite the append-only file","server","1.0.0"},
{"bgsave",NULL,"Asynchronously save the dataset to disk","server","1.0.0",.args=BGSAVE_Args,.numargs=1},
{"command",NULL,"Get array of Redis command details","server","2.8.13",.subcommands=COMMAND_Subcommands},
{"config",NULL,"A container for server configuration commands","server","2.0.0",.subcommands=CONFIG_Subcommands},
{"dbsize",NULL,"Return the number of keys in the selected database","server","1.0.0"},
{"debug",NULL,"A container for debugging commands","server","1.0.0"},
{"failover",NULL,"Start a coordinated failover between this server and one of its replicas.","server","6.2.0",.args=FAILOVER_Args,.numargs=3},
{"flushall",NULL,"Remove all keys from all databases","server","1.0.0",.args=FLUSHALL_Args,.numargs=1},
{"flushdb",NULL,"Remove all keys from the current database","server","1.0.0",.args=FLUSHDB_Args,.numargs=1},
{"info",NULL,"Get information and statistics about the server","server","1.0.0",.args=INFO_Args,.numargs=1},
{"lastsave",NULL,"Get the UNIX time stamp of the last successful save to disk","server","1.0.0"},
{"latency",NULL,"A container for latency diagnostics commands","server","2.8.13",.subcommands=LATENCY_Subcommands},
{"lolwut",NULL,"Display some computer art and the Redis version","server","5.0.0",.args=LOLWUT_Args,.numargs=1},
{"memory",NULL,"A container for memory diagnostics commands","server","4.0.0",.subcommands=MEMORY_Subcommands},
{"module",NULL,"A container for module commands","server","4.0.0",.subcommands=MODULE_Subcommands},
{"monitor",NULL,"Listen for all requests received by the server in real time","server","1.0.0"},
{"psync",NULL,"Internal command used for replication","server","2.8.0",.args=PSYNC_Args,.numargs=2},
{"replconf",NULL,"An internal command for configuring the replication stream","server","3.0.0"},
{"replicaof",NULL,"Make the server a replica of another instance, or promote it as master.","server","5.0.0",.args=REPLICAOF_Args,.numargs=2},
{"restore-asking",NULL,"An internal command for migrating keys in a cluster","server","3.0.0",.args=RESTORE_ASKING_Args,.numargs=7},
{"role",NULL,"Return the role of the instance in the context of replication","server","2.8.12"},
{"save",NULL,"Synchronously save the dataset to disk","server","1.0.0"},
{"shutdown",NULL,"Synchronously save the dataset to disk and then shut down the server","server","1.0.0",.args=SHUTDOWN_Args,.numargs=4},
{"slaveof",NULL,"Make the server a replica of another instance, or promote it as master.","server","1.0.0",.args=SLAVEOF_Args,.numargs=2},
{"slowlog",NULL,"A container for slow log commands","server","2.2.12",.subcommands=SLOWLOG_Subcommands},
{"swapdb",NULL,"Swaps two Redis databases","server","4.0.0",.args=SWAPDB_Args,.numargs=2},
{"sync",NULL,"Internal command used for replication","server","1.0.0"},
{"time",NULL,"Return the current server time","server","2.6.0"},
/* set */
{"sadd",NULL,"Add one or more members to a set","set","1.0.0",.args=SADD_Args,.numargs=2},
{"scard",NULL,"Get the number of members in a set","set","1.0.0",.args=SCARD_Args,.numargs=1},
{"sdiff",NULL,"Subtract multiple sets","set","1.0.0",.args=SDIFF_Args,.numargs=1},
{"sdiffstore",NULL,"Subtract multiple sets and store the resulting set in a key","set","1.0.0",.args=SDIFFSTORE_Args,.numargs=2},
{"sinter",NULL,"Intersect multiple sets","set","1.0.0",.args=SINTER_Args,.numargs=1},
{"sintercard",NULL,"Intersect multiple sets and return the cardinality of the result","set","7.0.0",.args=SINTERCARD_Args,.numargs=3},
{"sinterstore",NULL,"Intersect multiple sets and store the resulting set in a key","set","1.0.0",.args=SINTERSTORE_Args,.numargs=2},
{"sismember",NULL,"Determine if a given value is a member of a set","set","1.0.0",.args=SISMEMBER_Args,.numargs=2},
{"smembers",NULL,"Get all the members in a set","set","1.0.0",.args=SMEMBERS_Args,.numargs=1},
{"smismember",NULL,"Returns the membership associated with the given elements for a set","set","6.2.0",.args=SMISMEMBER_Args,.numargs=2},
{"smove",NULL,"Move a member from one set to another","set","1.0.0",.args=SMOVE_Args,.numargs=3},
{"spop",NULL,"Remove and return one or multiple random members from a set","set","1.0.0",.args=SPOP_Args,.numargs=2},
{"srandmember",NULL,"Get one or multiple random members from a set","set","1.0.0",.args=SRANDMEMBER_Args,.numargs=2},
{"srem",NULL,"Remove one or more members from a set","set","1.0.0",.args=SREM_Args,.numargs=2},
{"sscan",NULL,"Incrementally iterate Set elements","set","2.8.0",.args=SSCAN_Args,.numargs=4},
{"sunion",NULL,"Add multiple sets","set","1.0.0",.args=SUNION_Args,.numargs=1},
{"sunionstore",NULL,"Add multiple sets and store the resulting set in a key","set","1.0.0",.args=SUNIONSTORE_Args,.numargs=2},
/* sorted_set */
{"bzmpop",NULL,"Remove and return members with scores in a sorted set or block until one is available","sorted_set","7.0.0",.args=BZMPOP_Args,.numargs=5},
{"bzpopmax",NULL,"Remove and return the member with the highest score from one or more sorted sets, or block until one is available","sorted_set","5.0.0",.args=BZPOPMAX_Args,.numargs=2},
{"bzpopmin",NULL,"Remove and return the member with the lowest score from one or more sorted sets, or block until one is available","sorted_set","5.0.0",.args=BZPOPMIN_Args,.numargs=2},
{"zadd",NULL,"Add one or more members to a sorted set, or update its score if it already exists","sorted_set","1.2.0",.args=ZADD_Args,.numargs=6},
{"zcard",NULL,"Get the number of members in a sorted set","sorted_set","1.2.0",.args=ZCARD_Args,.numargs=1},
{"zcount",NULL,"Count the members in a sorted set with scores within the given values","sorted_set","2.0.0",.args=ZCOUNT_Args,.numargs=3},
{"zdiff",NULL,"Subtract multiple sorted sets","sorted_set","6.2.0",.args=ZDIFF_Args,.numargs=3},
{"zdiffstore",NULL,"Subtract multiple sorted sets and store the resulting sorted set in a new key","sorted_set","6.2.0",.args=ZDIFFSTORE_Args,.numargs=3},
{"zincrby",NULL,"Increment the score of a member in a sorted set","sorted_set","1.2.0",.args=ZINCRBY_Args,.numargs=3},
{"zinter",NULL,"Intersect multiple sorted sets","sorted_set","6.2.0",.args=ZINTER_Args,.numargs=5},
{"zintercard",NULL,"Intersect multiple sorted sets and return the cardinality of the result","sorted_set","7.0.0",.args=ZINTERCARD_Args,.numargs=3},
{"zinterstore",NULL,"Intersect multiple sorted sets and store the resulting sorted set in a new key","sorted_set","2.0.0",.args=ZINTERSTORE_Args,.numargs=5},
{"zlexcount",NULL,"Count the number of members in a sorted set between a given lexicographical range","sorted_set","2.8.9",.args=ZLEXCOUNT_Args,.numargs=3},
{"zmpop",NULL,"Remove and return members with scores in a sorted set","sorted_set","7.0.0",.args=ZMPOP_Args,.numargs=4},
{"zmscore",NULL,"Get the score associated with the given members in a sorted set","sorted_set","6.2.0",.args=ZMSCORE_Args,.numargs=2},
{"zpopmax",NULL,"Remove and return members with the highest scores in a sorted set","sorted_set","5.0.0",.args=ZPOPMAX_Args,.numargs=2},
{"zpopmin",NULL,"Remove and return members with the lowest scores in a sorted set","sorted_set","5.0.0",.args=ZPOPMIN_Args,.numargs=2},
{"zrandmember",NULL,"Get one or multiple random elements from a sorted set","sorted_set","6.2.0",.args=ZRANDMEMBER_Args,.numargs=2},
{"zrange",NULL,"Return a range of members in a sorted set","sorted_set","1.2.0",.args=ZRANGE_Args,.numargs=7},
{"zrangebylex",NULL,"Return a range of members in a sorted set, by lexicographical range","sorted_set","2.8.9",.args=ZRANGEBYLEX_Args,.numargs=4},
{"zrangebyscore",NULL,"Return a range of members in a sorted set, by score","sorted_set","1.0.5",.args=ZRANGEBYSCORE_Args,.numargs=5},
{"zrangestore",NULL,"Store a range of members from sorted set into another key","sorted_set","6.2.0",.args=ZRANGESTORE_Args,.numargs=7},
{"zrank",NULL,"Determine the index of a member in a sorted set","sorted_set","2.0.0",.args=ZRANK_Args,.numargs=2},
{"zrem",NULL,"Remove one or more members from a sorted set","sorted_set","1.2.0",.args=ZREM_Args,.numargs=2},
{"zremrangebylex",NULL,"Remove all members in a sorted set between the given lexicographical range","sorted_set","2.8.9",.args=ZREMRANGEBYLEX_Args,.numargs=3},
{"zremrangebyrank",NULL,"Remove all members in a sorted set within the given indexes","sorted_set","2.0.0",.args=ZREMRANGEBYRANK_Args,.numargs=3},
{"zremrangebyscore",NULL,"Remove all members in a sorted set within the given scores","sorted_set","1.2.0",.args=ZREMRANGEBYSCORE_Args,.numargs=3},
{"zrevrange",NULL,"Return a range of members in a sorted set, by index, with scores ordered from high to low","sorted_set","1.2.0",.args=ZREVRANGE_Args,.numargs=4},
{"zrevrangebylex",NULL,"Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.","sorted_set","2.8.9",.args=ZREVRANGEBYLEX_Args,.numargs=4},
{"zrevrangebyscore",NULL,"Return a range of members in a sorted set, by score, with scores ordered from high to low","sorted_set","2.2.0",.args=ZREVRANGEBYSCORE_Args,.numargs=5},
{"zrevrank",NULL,"Determine the index of a member in a sorted set, with scores ordered from high to low","sorted_set","2.0.0",.args=ZREVRANK_Args,.numargs=2},
{"zscan",NULL,"Incrementally iterate sorted sets elements and associated scores","sorted_set","2.8.0",.args=ZSCAN_Args,.numargs=4},
{"zscore",NULL,"Get the score associated with the given member in a sorted set","sorted_set","1.2.0",.args=ZSCORE_Args,.numargs=2},
{"zunion",NULL,"Add multiple sorted sets","sorted_set","6.2.0",.args=ZUNION_Args,.numargs=5},
{"zunionstore",NULL,"Add multiple sorted sets and store the resulting sorted set in a new key","sorted_set","2.0.0",.args=ZUNIONSTORE_Args,.numargs=5},
/* stream */
{"xack",NULL,"Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL.","stream","5.0.0",.args=XACK_Args,.numargs=3},
{"xadd",NULL,"Appends a new entry to a stream","stream","5.0.0",.args=XADD_Args,.numargs=5},
{"xautoclaim",NULL,"Changes (or acquires) ownership of messages in a consumer group, as if the messages were delivered to the specified consumer.","stream","6.2.0",.args=XAUTOCLAIM_Args,.numargs=7},
{"xclaim",NULL,"Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer.","stream","5.0.0",.args=XCLAIM_Args,.numargs=10},
{"xdel",NULL,"Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist.","stream","5.0.0",.args=XDEL_Args,.numargs=2},
{"xgroup",NULL,"A container for consumer groups commands","stream","5.0.0",.subcommands=XGROUP_Subcommands},
{"xinfo",NULL,"A container for stream introspection commands","stream","5.0.0",.subcommands=XINFO_Subcommands},
{"xlen",NULL,"Return the number of entries in a stream","stream","5.0.0",.args=XLEN_Args,.numargs=1},
{"xpending",NULL,"Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.","stream","5.0.0",.args=XPENDING_Args,.numargs=3},
{"xrange",NULL,"Return a range of elements in a stream, with IDs matching the specified IDs interval","stream","5.0.0",.args=XRANGE_Args,.numargs=4},
{"xread",NULL,"Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.","stream","5.0.0",.args=XREAD_Args,.numargs=3},
{"xreadgroup",NULL,"Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.","stream","5.0.0",.args=XREADGROUP_Args,.numargs=5},
{"xrevrange",NULL,"Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE","stream","5.0.0",.args=XREVRANGE_Args,.numargs=4},
{"xsetid",NULL,"An internal command for replicating stream values","stream","5.0.0",.args=XSETID_Args,.numargs=4},
{"xtrim",NULL,"Trims the stream to (approximately if '~' is passed) a certain size","stream","5.0.0",.args=XTRIM_Args,.numargs=2},
/* string */
{"append",NULL,"Append a value to a key","string","2.0.0",.args=APPEND_Args,.numargs=2},
{"decr",NULL,"Decrement the integer value of a key by one","string","1.0.0",.args=DECR_Args,.numargs=1},
{"decrby",NULL,"Decrement the integer value of a key by the given number","string","1.0.0",.args=DECRBY_Args,.numargs=2},
{"get",NULL,"Get the value of a key","string","1.0.0",.args=GET_Args,.numargs=1},
{"getdel",NULL,"Get the value of a key and delete the key","string","6.2.0",.args=GETDEL_Args,.numargs=1},
{"getex",NULL,"Get the value of a key and optionally set its expiration","string","6.2.0",.args=GETEX_Args,.numargs=2},
{"getrange",NULL,"Get a substring of the string stored at a key","string","2.4.0",.args=GETRANGE_Args,.numargs=3},
{"getset",NULL,"Set the string value of a key and return its old value","string","1.0.0",.args=GETSET_Args,.numargs=2},
{"incr",NULL,"Increment the integer value of a key by one","string","1.0.0",.args=INCR_Args,.numargs=1},
{"incrby",NULL,"Increment the integer value of a key by the given amount","string","1.0.0",.args=INCRBY_Args,.numargs=2},
{"incrbyfloat",NULL,"Increment the float value of a key by the given amount","string","2.6.0",.args=INCRBYFLOAT_Args,.numargs=2},
{"lcs",NULL,"Find longest common substring","string","7.0.0",.args=LCS_Args,.numargs=6},
{"mget",NULL,"Get the values of all the given keys","string","1.0.0",.args=MGET_Args,.numargs=1},
{"mset",NULL,"Set multiple keys to multiple values","string","1.0.1",.args=MSET_Args,.numargs=1},
{"msetnx",NULL,"Set multiple keys to multiple values, only if none of the keys exist","string","1.0.1",.args=MSETNX_Args,.numargs=1},
{"psetex",NULL,"Set the value and expiration in milliseconds of a key","string","2.6.0",.args=PSETEX_Args,.numargs=3},
{"set",NULL,"Set the string value of a key","string","1.0.0",.args=SET_Args,.numargs=5},
{"setex",NULL,"Set the value and expiration of a key","string","2.0.0",.args=SETEX_Args,.numargs=3},
{"setnx",NULL,"Set the value of a key, only if the key does not exist","string","1.0.0",.args=SETNX_Args,.numargs=2},
{"setrange",NULL,"Overwrite part of a string at key starting at the specified offset","string","2.2.0",.args=SETRANGE_Args,.numargs=3},
{"strlen",NULL,"Get the length of the value stored in a key","string","2.2.0",.args=STRLEN_Args,.numargs=1},
{"substr",NULL,"Get a substring of the string stored at a key","string","1.0.0",.args=SUBSTR_Args,.numargs=3},
/* transactions */
{"discard",NULL,"Discard all commands issued after MULTI","transactions","2.0.0"},
{"exec",NULL,"Execute all commands issued after MULTI","transactions","1.2.0"},
{"multi",NULL,"Mark the start of a transaction block","transactions","1.2.0"},
{"unwatch",NULL,"Forget about all watched keys","transactions","2.2.0"},
{"watch",NULL,"Watch the given keys to determine execution of the MULTI/EXEC block","transactions","2.2.0",.args=WATCH_Args,.numargs=1},
{0}
};
